# 基础算法

## 查找算法

### 一、二分查找

在有序数组中通过将目标值与数组中间值比较，每次将查找范围缩小一半。高效查找的经典算法，时间复杂度为 O(log n)。

时间复杂度:最佳 O(1) | 平均 O(log n) | 最差 O(log n)     空间复杂度:O(1).>

>##### 应用场景/前提条件：
>
>数组必须是有序的才能应用二分查找

#### 算法讲解

##### 介绍

二分查找（Binary Search）是一种高效的查找算法，也叫折半查找。核心思想：对于一个**有序**的数据集合，每次查找都将查找范围缩小为原来的一半，直到找到目标值或确定目标值不存在。二分查找要求数据必须是有序的，经常应用于数组等支持随机访问的数据结构里。跟线性查找相比，二分查找的效率要高得多，特别是对于大规模数据集。

#### 算法步骤

1. 确定查找范围的左边界 left 和右边界 right
2. 计算中间位置 mid = (left + right) / 2（注意整数溢出问题，更安全的做法是 mid = left + (right - left) / 2）
3. 将中间位置的元素与目标值比较
   - 如果中间元素等于目标值，查找成功，返回中间元素的位置
   - 如果中间元素大于目标值，目标值可能在左半部分，将右边界调整为 mid - 1
   - 如果中间元素小于目标值，目标值可能在右半部分，将左边界调整为 mid + 1
4. 重复步骤2-3，直到找到目标值或者左边界大于右边界（此时表示目标值不存在）

![img](https://bu.dusays.com/2025/09/21/68cfe9386c814.webp)

#### 核心特性

- **要求有序**：二分查找只适用于有序数据集合
- **时间复杂度**：O(log n)，在大规模数据集上非常高效
- **空间复杂度**：迭代实现为O(1)，递归实现为O(log n)（因为递归调用栈的深度）
- **随机访问**：要求数据结构支持O(1)时间复杂度的随机访问（比如数组）

#### 代码实现

```java
public class BinarySearch {
    // 迭代实现
    public static int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            // 避免整数溢出
            int mid = left + (right - left) / 2;
            
            // 找到目标值
            if (arr[mid] == target) {
                return mid;
            }
            // 在左半部分继续查找
            else if (arr[mid] > target) {
                right = mid - 1;
            }
            // 在右半部分继续查找
            else {
                left = mid + 1;
            }
        }
        
        // 未找到目标值
        return -1;
    }
    
    // 递归实现
    public static int binarySearchRecursive(int[] arr, int target, int left, int right) {
        if (left > right) {
            return -1;
        }
        
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] > target) {
            return binarySearchRecursive(arr, target, left, mid - 1);
        } else {
            return binarySearchRecursive(arr, target, mid + 1, right);
        }
    }
    
    // 测试
    public static void main(String[] args) {
        int[] arr = {2, 3, 4, 10, 40, 50, 70, 80};
        int target = 10;
        
        // 迭代方法
        int result = binarySearch(arr, target);
        if (result == -1) {
            System.out.println("元素 " + target + " 不存在于数组中");
        } else {
            System.out.println("元素 " + target + " 在数组中的索引为 " + result);
        }
        
        // 递归方法
        result = binarySearchRecursive(arr, target, 0, arr.length - 1);
        if (result == -1) {
            System.out.println("元素 " + target + " 不存在于数组中");
        } else {
            System.out.println("元素 " + target + " 在数组中的索引为 " + result);
        }
    }
}

```

#### 优缺点

##### 优点

- 查找效率非常高，时间复杂度为 O(log n)
- 在大规模数据集上表现优异
- 实现相对简单
- 不需要额外的空间（迭代实现）

##### 缺点

- 要求数据必须是有序的
- 只适用于支持随机访问的数据结构（如数组）
- 对于频繁插入和删除的数据结构，维护有序性的成本很高
- 不适合小数据量的查找（这种情况下线性查找可能更快）

##### 应用场景

#### 扩展

二分查找在很多场景中都有广泛的应用：

- 数据库索引的实现（如 B 树和 B+ 树的查找过程）

- 查找最接近某个值的元素（下界查找和上界查找）

- 计算平方根等数值计算中（二分法求解）

- 猜数字游戏（每次猜测中间值）

- 在旋转排序数组中查找元素

- 查找数组中第一个或最后一个满足某条件的元素

  ###### 二分查找的变种

  二分查找有许多变种，用来解决不同的问题：

###### 查找第一个等于目标值的值：

```java
public static int findFirstEqual(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] > target) {
            right = mid - 1;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            // 找到目标值，但需要继续向左查找是否有相同值
            result = mid;
            right = mid - 1;
        }
    }
    
    return result;
}

```



#### 测验

1. 二分查找的时间复杂度是多少？为什么它比线性查找更高效？
2. 二分查找的前提条件是什么？它适用于哪些数据结构？
3. 为什么计算中间位置时，推荐使用 `mid = left + (right - left) / 2` 而不是 `mid = (left + right) / 2`？
4. 在有重复元素的有序数组中，如何找到目标值的第一次出现位置？
5. 二分查找的递归实现和迭代实现在空间复杂度上有何区别？

> 测验答案
>
> 1. O(log n)。因为每次查找都将搜索范围缩小一半，线性查找需要遍历全部元素。
> 2. 数据必须有序。适用于支持随机访问的数据结构，如数组。
> 3. `mid = left + (right - left) / 2` 可以避免在处理大数组的时候可能发生的整数溢出问题。如果 left 和 right 都很大，它们的和有可能超过整数类型的最大值。
> 4. 找到目标值后不立即返回，记录当前位置，继续在左半部分查找（将 right 设为 mid - 1），直到找不到为止，最后返回记录的位置。
> 5. 迭代实现空间复杂度为 O(1)，只需常量级的额外空间；递归实现的空间复杂度为 O(log n)，因为递归调用栈的深度与二分查找的次数成正比。



### 二、线性查找

从头到尾逐个检查数组中的每个元素，直到找到目标值或遍历完整个数组。简单直观但效率较低，适合小型或无序数据集。

时间复杂度:最佳 O(1) | 平均 O(n/2) | 最差 O(n)    空间复杂度:O(1)

>##### 应用场景/前提条件
>
>- 适用于无序数据
>- 适合小规模数据集

#### 算法讲解

##### 介绍

线性查找（Linear Search），也称为顺序查找（Sequential Search），是最简单的一种查找算法。它的工作原理是：从数据结构的第一个元素开始，按顺序依次检查每个元素，直到找到目标值或者遍历完整个数据结构。线性查找不要求数据必须是有序的，适用于各种数据集合。

##### 算法步骤

1. 从数据结构的第一个元素开始
2. 将当前元素与要查找的目标值进行比较
3. 如果当前元素等于目标值，则查找成功，返回元素的位置
4. 如果当前元素不等于目标值，则继续检查下一个元素
5. 重复步骤2-4，直到找到目标值或者遍历完所有元素
6. 如果遍历完所有元素仍未找到目标值，则查找失败，返回表示失败的信息（如-1）

![img](https://bu.dusays.com/2025/09/21/68cfeb17ab451.webp)

#### 核心特性

- **简单性**：算法思路简单，易于实现
- **适用性**：适用于任何数据结构，不需要需预先排序
- **时间复杂度**：最好情况O(1)，最坏和平均情况均为O(n)
- **空间复杂度**：O(1)，只需要常数级的额外空间

#### 代码实现

```java
public class LinearSearch {
    public static int linearSearch(int[] arr, int target) {
        // 遍历数组
        for (int i = 0; i < arr.length; i++) {
            // 找到目标值，返回索引
            if (arr[i] == target) {
                return i;
            }
        }
        // 未找到目标值，返回-1
        return -1;
    }
    
    // 测试
    public static void main(String[] args) {
        int[] arr = {10, 20, 80, 30, 60, 50, 110, 100, 130, 170};
        int target = 110;
        
        int result = linearSearch(arr, target);
        if (result == -1) {
            System.out.println("元素 " + target + " 不存在于数组中");
        } else {
            System.out.println("元素 " + target + " 在数组中的索引为 " + result);
        }
    }
}

```

#### 优缺点

##### 优点

- 实现极其简单，代码量少
- 不需要预先排序数据
- 适用于任何数据结构
- 对于小规模数据集效率可以接受
- 无额外空间要求

##### 缺点

- 时间复杂度为O(n)，当数据量大时效率低下
- 不利用数据的任何特征（如有序性）来加速查找
- 对于有序数据，不如二分查找高效
- 随着数据规模增长，性能下降显著

#### 应用场景

虽然线性查找效率不高，但在小部分场景中仍然有一定的适用性：

- 小规模数据集的查找
- 无序数据集的查找
- 仅需查找一次或偶尔查找的场景
- 对算法实现简单性要求高于效率的场景
- 作为其他高级查找算法的基础或回退方案
- 适合用作教学或算法入门学习

#### 测验

### 三、跳跃查找

在有序数组中，通过跳跃固定步长来缩小查找范围，然后在确定的区间内进行线性查找。结合了二分查找和线性查找的优点。

时间复杂度:最佳 O(1) | 平均 O(√n) | 最差 O(√n)     空间复杂度:O(1)

>##### 应用场景/前提条件
>
>- 数组必须是有序的
>- 较适合大型数据集

1. 线性查找的平均时间复杂度是多少？
2. 当数据已经有序时，线性查找的效率会提高吗？为什么？
3. 线性查找的空间复杂度是多少？为什么？

> 测验答案
>
> 1. 线性查找的平均时间复杂度是O(n)。
> 2. 不会。线性查找无论数据是否有序，都需要从头开始逐个检查，直到找到目标值或遍历完整个数据结构。
> 3. 线性查找的空间复杂度是O(1)，它只需要常量级的额外空间来存储循环变量和比较结果，不随输入数据规模改变。

#### 算法讲解

##### 介绍

跳跃查找（Jump Search）是一种在有序数组中查找元素的算法，核心思想是通过跳过固定步长的元素来缩小搜索范围，然后在缩小的区间内进行线性查找。跳跃查找是**二分查找和线性查找的混合体**，特别适合**大型有序数据集**。

跳跃查找的效率取决于步长的选择。在最佳情况下，跳跃查找的时间复杂度可以达到 O(√n)，优于线性查找的 O(n)，但不如二分查找的 O(log n)。但是在一些具体场景下，跳跃查找比二分查找表现更好，比如当内存中访问顺序元素比随机访问更高效的时候。

#### 算法步骤

1. 确定跳跃步长（通常取 √n，n 是数组长度）
2. 从数组开头开始，每次跳过步长个元素，直到找到大于或等于目标值的元素或达到数组末尾
3. 如果找到的元素大于目标值，则回退一步，在该区间内进行线性查找
4. 如果找到目标值，返回其索引；否则返回未找到标识

![img](https://bu.dusays.com/2025/09/21/68cfebdb35bc9.webp)

#### 核心特性

- **分块查找**：将数组分成大小为 √n 的块，跳跃式地查找
- **步长选择**：最优步长为 √n，在时间和空间复杂度间取得平衡
- **时间复杂度**：平均情况为 O(√n)
- **空间复杂度**：O(1)，不需要额外空间
- **适用条件**：必须在有序数组上进行操作

#### 代码实现

```java
public class JumpSearch {
    public static int jumpSearch(int[] arr, int target) {
        int n = arr.length;
        
        // 确定最佳步长
        int step = (int) Math.floor(Math.sqrt(n));
        
        // 跳跃查找阶段
        int prev = 0;
        while (arr[Math.min(step, n) - 1] < target) {
            prev = step;
            step += (int) Math.floor(Math.sqrt(n));
            if (prev >= n) {
                return -1;  // 未找到元素
            }
        }
        
        // 线性查找阶段
        while (arr[prev] < target) {
            prev++;
            
            // 如果已到达下一步长或数组末尾，则未找到元素
            if (prev == Math.min(step, n)) {
                return -1;
            }
        }
        
        // 检查是否找到目标元素
        if (arr[prev] == target) {
            return prev;  // 返回元素索引
        }
        
        return -1;  // 未找到元素
    }
    
    // 测试
    public static void main(String[] args) {
        int[] arr = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610};
        int target = 55;
        
        int index = jumpSearch(arr, target);
        
        if (index != -1) {
            System.out.println("元素 " + target + " 在索引 " + index + " 处找到");
        } else {
            System.out.println("元素 " + target + " 未在数组中找到");
        }
    }
}

```



注意，在上述代码里，通过：

```java
// 确定最佳步长
int step = (int) Math.floor(Math.sqrt(n));
```

确定了跳跃查找最关键的步长参数，这里会直接影响算法的效率。

```java
function jumpSearch(arr, target) {
    const n = arr.length;
    
    // 确定最佳步长
    const step = Math.floor(Math.sqrt(n));
    
    // 跳跃查找阶段
    let prev = 0;
    while (arr[Math.min(step, n) - 1] < target) {
        prev = step;
        step += Math.floor(Math.sqrt(n));
        if (prev >= n) {
            return -1;  // 未找到元素
        }
    }
    
    // 线性查找阶段
    while (arr[prev] < target) {
        prev++;
        
        // 如果已到达下一步长或数组末尾，则未找到元素
        if (prev == Math.min(step, n)) {
            return -1;
        }
    }
    
    // 检查是否找到目标元素
    if (arr[prev] == target) {
        return prev;  // 返回元素索引
    }
    
    return -1;  // 未找到元素
}

// 测试
const arr = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610];
const target = 55;

const index = jumpSearch(arr, target);

if (index !== -1) {
    console.log(`元素 ${target} 在索引 ${index} 处找到`);
} else {
    console.log(`元素 ${target} 未在数组中找到`);
}

```

##### 优化策略

###### 自适应步长

根据数据规模动态调整步长：

```java
public static int optimizedJumpSearch(int[] arr, int target) {
    int n = arr.length;
    
    // 根据数组大小调整步长
    int step;
    if (n <= 100) {
        step = 5;  // 小数组使用较小步长
    } else if (n <= 10000) {
        step = (int) Math.floor(Math.sqrt(n));  // 中等数组使用标准步长
    } else {
        step = (int) Math.floor(Math.cbrt(n) * 3);  // 大数组使用更大步长
    }
    
    // 后续跳跃查找逻辑
    // ...
}

```

##### 缓存友好优化

根据计算机缓存特性优化：

```java
public static int cacheOptimizedJumpSearch(int[] arr, int target) {
    int n = arr.length;
    
    // 根据缓存行大小选择步长
    // 假设每个缓存行为64字节，每个int为4字节，则一个缓存行可以存储16个int
    int cacheLineSize = 16;
    int step = (int) Math.floor(Math.sqrt(n / cacheLineSize)) * cacheLineSize;
    
    if (step < cacheLineSize) {
        step = cacheLineSize;
    }
    
    // 后续跳跃查找逻辑
    // ...
}

```

#### 优缺点

##### 优点

- 比线性查找更高效，时间复杂度为 O(√n)
- 比二分查找更易于实现
- 在链表等只能顺序访问的数据结构上有优势
- 良好的内存局部性，更利于缓存命中

##### 缺点

- 时间复杂度不如二分查找的 O(log n)
- 性能对步长的选择比较敏感
- 必须是有序数组
- 对于小数组，优势不明显
- 针对频繁动态变化的数据结构，需要重新计算最优步长

#### 应用场景

1）处理大型有序数组，尤其是当内存访问成本高时

2）在内存局部性要求高的系统中，如嵌入式系统或低级系统优化

3）随机访问成本高于顺序访问时作为二分查找的替代方案

4）在链表等顺序访问数据结构上查找

5）外部存储设备上的数据查找，比如磁盘存储，顺序读取比随机读取更高效

#### 扩展

##### 跳跃链表实现

将跳跃查找的思想应用到链表数据结构：

```java
class Node {
    int data;
    Node next;
    
    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

public static int jumpSearchInLinkedList(Node head, int target) {
    if (head == null) {
        return -1;
    }
    
    // 计算链表长度
    int length = 0;
    Node temp = head;
    while (temp != null) {
        length++;
        temp = temp.next;
    }
    
    // 确定步长
    int step = (int) Math.floor(Math.sqrt(length));
    
    // 跳跃查找阶段
    Node current = head;
    Node prev = null;
    int position = 0;
    
    while (current != null && current.data < target) {
        // 记住上一个跳跃点
        prev = current;
        
        // 跳跃到下一个位置
        for (int i = 0; i < step && current != null; i++) {
            current = current.next;
            position++;
        }
    }
    
    // 回退到上一个跳跃点
    if (current == null || (current != head && current.data > target)) {
        current = prev;
        position -= step;
    }
    
    // 线性查找阶段
    while (current != null && current.data < target) {
        current = current.next;
        position++;
    }
    
    // 检查是否找到目标元素
    if (current != null && current.data == target) {
        return position;
    }
    
    return -1;  // 未找到元素
}

```

##### 跳跃查找与其他算法组合

在大型数据结构中结合多种查找算法：

```java
public static int hybridSearch(int[] arr, int target) {
    int n = arr.length;
    
    // 根据数组大小选择算法
    if (n <= 20) {
        // 小数组使用线性查找
        return linearSearch(arr, target);
    } else if (n <= 1000) {
        // 中等数组使用跳跃查找
        return jumpSearch(arr, target);
    } else {
        // 大数组使用二分查找
        return binarySearch(arr, target);
    }
}

private static int linearSearch(int[] arr, int target) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;
}

private static int binarySearch(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        }
        
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}

```

#### 测验

这里准备了一些测试题，方便大家判断自己的掌握情况：

1. 跳跃查找的最优步长是多少？为什么这个步长是最优的？
2. 跳跃查找的时间复杂度是多少？与线性查找和二分查找相比如何？
3. 在什么情况下，跳跃查找比二分查找更有优势？

> 测验答案
>
> 1. 跳跃查找的最优步长是 √n，其中 n 是数组长度。这个步长在时间复杂度方面达到了最优平衡，让算法的时间复杂度达到 O(√n)。
> 2. O(√n)，优于线性查找的 O(n)，但不如二分查找的 O(log n)。
> 3. 顺序访问比随机访问更高效的时候，跳跃查找比二分查找更好用，比如在链表、磁盘存储或缓存友好型系统中。

### 四、哈希查找

#### 哈希查找

通过哈希函数将元素映射到固定大小的表中进行快速查找，平均时间复杂度为O(1)，适合大规模数据查找。

时间复杂度:最佳 O(1) | 平均 O(1) | 最差 O(n)    空间复杂度:O(n)

>##### 应用场景/前提条件
>
>- 需要预先构建哈希表
>- 处理哈希冲突的策略（如链地址法或开放寻址法）

#### 算法讲解

##### 介绍

哈希查找（Hash Search），又称散列查找，是一种高效的查找算法，它用哈希函数将数据转换为数组下标，然后直接访问数组中的元素。哈希查找的核心思想是**将数据元素通过哈希函数映射到哈希表中的位置，实现快速查找**。

在理想情况下，哈希查找的时间复杂度为 O(1)，这就意味着无论数据规模多大，查找操作都能在常数时间内完成，这是哈希查找相比其他查找算法（如二分查找、线性查找）的最大优势。

不过使用哈希查找必须要考虑哈希冲突（不同的数据被映射到相同的位置）问题。

#### 算法步骤

1. 设计一个适合数据特点的哈希函数，将数据映射到哈希表的索引位置
2. 构建哈希表，将所有元素通过哈希函数映射、存储到相应位置
3. 解决可能出现的哈希冲突（通常采用链地址法或开放寻址法）
4. 查找时，通过同样的哈希函数计算目标数据的哈希值
5. 根据哈希值定位到哈希表中的位置
6. 如果存在冲突，则按照解决冲突的方法查找目标元素

![img](https://bu.dusays.com/2025/09/21/68cfed99be17b.webp)

#### 核心特性

- **快速访问**：理想情况下查找时间复杂度为 O(1)
- **哈希函数**：哈希查找的核心，将数据映射到数组索引的函数
- **哈希冲突**：不同数据映射到相同位置的情况，需要特殊处理
- **空间换时间**：通过额外的内存空间换取查找时间的提升
- **负载因子**：表示哈希表的填充程度，影响查找效率和冲突概率
- **动态扩容**：负载因子过高时，需要扩大哈希表并重新哈希**所有**元素

#### 代码实现

```java
public class HashSearch {
    // 哈希表节点类
    static class Node {
        String key;
        int value;
        Node next;
        
        public Node(String key, int value) {
            this.key = key;
            this.value = value;
            this.next = null;
        }
    }
    
    // 哈希表类
    static class HashTable {
        private Node[] buckets;
        private int capacity;
        private int size;
        private final float LOAD_FACTOR = 0.75f; // 负载因子阈值
        
        public HashTable(int capacity) {
            this.capacity = capacity;
            this.buckets = new Node[capacity];
            this.size = 0;
        }
        
        // 哈希函数
        private int hash(String key) {
            int hash = 0;
            for (char c : key.toCharArray()) {
                hash = (hash * 31 + c) % capacity;
            }
            return Math.abs(hash);
        }
        
        // 插入键值对
        public void put(String key, int value) {
            if ((float)size / capacity >= LOAD_FACTOR) {
                resize(2 * capacity);
            }
            
            int index = hash(key);
            Node newNode = new Node(key, value);
            
            // 如果桶为空，直接插入
            if (buckets[index] == null) {
                buckets[index] = newNode;
                size++;
                return;
            }
            
            // 处理哈希冲突，使用链地址法
            Node current = buckets[index];
            
            // 检查是否已存在相同的键
            while (current != null) {
                if (current.key.equals(key)) {
                    current.value = value; // 更新值
                    return;
                }
                if (current.next == null) {
                    break;
                }
                current = current.next;
            }
            
            // 在链表末尾添加新节点
            current.next = newNode;
            size++;
        }
        
        // 查找键对应的值
        public Integer get(String key) {
            int index = hash(key);
            Node current = buckets[index];
            
            // 遍历链表查找匹配的键
            while (current != null) {
                if (current.key.equals(key)) {
                    return current.value;
                }
                current = current.next;
            }
            
            // 未找到
            return null;
        }
        
        // 删除键值对
        public boolean remove(String key) {
            int index = hash(key);
            Node current = buckets[index];
            Node prev = null;
            
            // 查找目标节点
            while (current != null) {
                if (current.key.equals(key)) {
                    break;
                }
                prev = current;
                current = current.next;
            }
            
            // 未找到目标节点
            if (current == null) {
                return false;
            }
            
            // 删除节点
            if (prev == null) {
                buckets[index] = current.next;
            } else {
                prev.next = current.next;
            }
            
            size--;
            return true;
        }
        
        // 扩容并重新哈希
        private void resize(int newCapacity) {
            Node[] oldBuckets = buckets;
            
            // 创建新的哈希表
            buckets = new Node[newCapacity];
            capacity = newCapacity;
            size = 0;
            
            // 重新哈希所有元素
            for (Node bucket : oldBuckets) {
                Node current = bucket;
                while (current != null) {
                    put(current.key, current.value);
                    current = current.next;
                }
            }
        }
    }
    
    public static void main(String[] args) {
        HashTable hashTable = new HashTable(10);
        
        // 插入数据
        hashTable.put("apple", 5);
        hashTable.put("banana", 10);
        hashTable.put("orange", 15);
        hashTable.put("grape", 20);
        
        // 查找数据
        System.out.println("apple: " + hashTable.get("apple"));
        System.out.println("banana: " + hashTable.get("banana"));
        System.out.println("orange: " + hashTable.get("orange"));
        System.out.println("grape: " + hashTable.get("grape"));
        System.out.println("watermelon: " + hashTable.get("watermelon"));
        
        // 删除数据
        hashTable.remove("orange");
        System.out.println("After removing orange: " + hashTable.get("orange"));
    }
}

```

##### 哈希冲突解决方法

哈希查找的核心问题是如何处理哈希冲突。下面是两种主要的解决方案：

##### 链地址法（Separate Chaining）:

```java
public void chainInsert(String key, int value) {
    int index = hash(key);
    Node newNode = new Node(key, value);
    
    // 如果桶为空，直接插入
    if (buckets[index] == null) {
        buckets[index] = newNode;
        return;
    }
    
    // 否则遍历链表
    Node current = buckets[index];
    while (current.next != null) {
        // 如果找到相同的键，更新值
        if (current.key.equals(key)) {
            current.value = value;
            return;
        }
        current = current.next;
    }
    
    // 在链表末尾添加新节点
    if (current.key.equals(key)) {
        current.value = value;
    } else {
        current.next = newNode;
    }
}

```

#### 优缺点

##### 优点

- 查找、插入和删除操作的平均时间复杂度为 O(1)
- 适用于快速查找
- 不要求数据有序，更灵活
- 支持动态数据集，高效地添加和删除元素
- 通过合适的哈希函数和解决冲突策略，能实现非常优秀的性能

##### 缺点

- 哈希冲突会降低查找效率，最坏情况下时间复杂度可能退化到 O(n)
- 需要额外的空间存储哈希表
- 不支持范围查询，不适合按顺序遍历场景
- 负载因子过高会导致性能下降，过低会浪费空间

#### 应用场景

哈希查找适用于以下场景：

- 需要快速查找、插入和删除操作的数据结构，如字典或映射
- 实现缓存系统，比如LRU缓存、内存缓存等
- 数据库索引，特别是等值查询
- 符号表实现，如编译器和解释器中的变量表
- 去重操作，判断元素是否已存在
- 网页爬虫的URL去重

#### 扩展

##### 一致性哈希

一致性哈希是**分布式系统**中的重要概念，目的是尽可能少地重新分配数据：

```java
public class ConsistentHash {
    private final int numberOfReplicas; // 虚拟节点数量
    private final SortedMap<Integer, String> circle = new TreeMap<>();
    
    public ConsistentHash(int numberOfReplicas, Collection<String> nodes) {
        this.numberOfReplicas = numberOfReplicas;
        for (String node : nodes) {
            addNode(node);
        }
    }
    
    // 添加节点
    public void addNode(String node) {
        for (int i = 0; i < numberOfReplicas; i++) {
            String virtualNode = node + "#" + i;
            int hash = getHash(virtualNode);
            circle.put(hash, node);
        }
    }
    
    // 移除节点
    public void removeNode(String node) {
        for (int i = 0; i < numberOfReplicas; i++) {
            String virtualNode = node + "#" + i;
            int hash = getHash(virtualNode);
            circle.remove(hash);
        }
    }
    
    // 获取数据应该存储的节点
    public String getNode(String key) {
        if (circle.isEmpty()) {
            return null;
        }
        
        int hash = getHash(key);
        
        // 如果没有大于等于该hash值的节点，则返回第一个节点
        if (!circle.containsKey(hash)) {
            SortedMap<Integer, String> tailMap = circle.tailMap(hash);
            hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey();
        }
        
        return circle.get(hash);
    }
    
    // 哈希函数
    private int getHash(String key) {
        return Math.abs(key.hashCode()) % 359;
    }
}

```

##### 布隆过滤器

布隆过滤器是一种空间效率高的概率型数据结构，判断一个元素是否在集合中：

```java
public class BloomFilter {
    private BitSet bitSet;
    private int bitSetSize;
    private int numHashFunctions;
    
    public BloomFilter(int expectedInsertions, double falsePositiveProbability) {
        // 计算最佳bit数组大小
        this.bitSetSize = (int) Math.ceil(-(expectedInsertions * Math.log(falsePositiveProbability)) / (Math.log(2) * Math.log(2)));
        
        // 计算最佳哈希函数数量
        this.numHashFunctions = (int) Math.ceil((bitSetSize / expectedInsertions) * Math.log(2));
        
        this.bitSet = new BitSet(bitSetSize);
    }
    
    // 添加元素
    public void add(String element) {
        for (int i = 0; i < numHashFunctions; i++) {
            int hash = getHash(element, i);
            bitSet.set(hash);
        }
    }
    
    // 检查元素是否可能在集合中
    public boolean mightContain(String element) {
        for (int i = 0; i < numHashFunctions; i++) {
            int hash = getHash(element, i);
            if (!bitSet.get(hash)) {
                return false; // 肯定不在集合中
            }
        }
        return true; // 可能在集合中
    }
    
    // 生成多个哈希值
    private int getHash(String element, int index) {
        int hash1 = element.hashCode();
        int hash2 = hash1 >>> 16;
        return Math.abs((hash1 + index * hash2) % bitSetSize);
    }
}

```

#### 测验

1. 什么是哈希查找？它的平均时间复杂度是多少？
2. 什么是哈希冲突？列举两种常见的解决方法。
3. 负载因子对哈希表性能有什么影响？
4. 哈希函数的设计原则有哪些？
5. 开放寻址法中的线性探测、二次探测和双重哈希有什么区别？

> 测验答案
>
> 1. 一种通过哈希函数将数据转换为数组下标，然后直接访问数组中元素的查找算法，平均时间复杂度为 O(1)。
> 2. 哈希冲突是指不同的数据通过哈希函数得到相同的哈希值。常见的解决方法有：（1）链地址法：在冲突位置建立链表；（2）开放寻址法：在原始位置基础上按照某种方式寻找下一个可用位置。
> 3. 负载因子表示哈希表的填充程度。负载因子过高会增加哈希冲突概率，降低查找效率；负载因子过低会浪费空间。哈希表通常在负载因子达到某个阈值（比如0.75）时进行扩容。
> 4. （1）计算简单高效；（2）尽可能均匀分布，减少冲突；（3）具有雪崩效应，输入微小变化导致输出显著不同；（4）确定性，相同输入产生相同输出。
> 5. 线性探测：冲突时按固定步长（一般是 1）向后查找空位；二次探测：冲突时按二次方向后查找；双重哈希：冲突时使用第二个哈希函数计算步长。二次探测和双重哈希都可以减轻线性探测的聚集问题。

## 排序算法

### 一、冒泡排序

#### 冒泡排序

冒泡排序是一种简单的排序算法，通过相邻元素的比较和交换，使较大的元素逐渐"浮"到数组末尾。

时间复杂度:最佳 O(n) | 平均 O(n²) | 最差 O(n²)     空间复杂度:O(1)

稳定性:稳定

>##### 应用场景/前提条件
>
>- 适用于小规模数据
>- 对几乎已排序的数据效率较高

#### 算法讲解

##### 介绍

冒泡排序（Bubble Sort）的核心思想非常简单：**从头开始，不断比较相邻的两个元素，如果前者比后者大，就交换位置。** 这样从头到尾完整地走一趟，最大的那个元素就必然会“沉”到队尾的最终位置。只需不断重复这个过程，每一轮都将当前未排序部分的最大值找出来送到末端，直到所有元素都排列整齐。因为在这个过程中较小的元素会像气泡一样逐渐“冒”到数组的前方，所以叫冒泡排序故得此名。

#### 算法步骤

1. 比较相邻的元素。如果第一个比第二个大，就交换它们
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对
3. 这步做完后，最后的元素会是最大的数
4. 针对所有的元素重复以上的步骤，除了已经是最大数的最后一个
5. 持续每次对越来越少(每次重复都会少一个最大数)的元素重复上面的步骤，直到没有任何一对数字需要比较

为了帮助大家更好的理解，我们以初始数组 `[5, 3, 8, 4, 2]` 为例，查看每一步的详细流程：

------

##### 第一轮

在此轮中，比较将进行4次，目标是将当前数组中的最大值移动到最右边。

1. 比较 5 和 3，5 > 3，交换。数组变为 `[3, 5, 8, 4, 2]`。
2. 比较 5 和 8，5 < 8，不交换。
3. 比较 8 和 4，8 > 4，交换。数组变为 `[3, 5, 4, 8, 2]`。
4. 比较 8 和 2，8 > 2，交换。数组变为 `[3, 5, 4, 2, 8]`。

本轮结束后，数组为 `[3, 5, 4, 2, 8]`。最大元素 8 已经到达其最终的正确位置。

------

##### 第二轮

现在，我们只对前面未排序的4个元素 `[3, 5, 4, 2]` 重复此过程。

1. 比较 3 和 5，3 < 5，不交换。
2. 比较 5 和 4，5 > 4，交换。数组变为 `[3, 4, 5, 2, 8]`。
3. 比较 5 和 2，5 > 2，交换。数组变为 `[3, 4, 2, 5, 8]`。

本轮结束后，数组为 `[3, 4, 2, 5, 8]`。次大元素 5 也到达了它的正确位置。

------

##### 第三轮

对前面未排序的3个元素 `[3, 4, 2]` 重复此过程。

1. 比较 3 和 4，3 < 4，不交换。
2. 比较 4 和 2，4 > 2，交换。数组变为 `[3, 2, 4, 5, 8]`。

本轮结束后，数组为 `[3, 2, 4, 5, 8]`。元素 4 到达了它的正确位置。

------

##### 第四轮

对前面未排序的2个元素 `[3, 2]` 重复此过程。

1. 比较 3 和 2，3 > 2，交换。数组变为 `[2, 3, 4, 5, 8]`。

本轮结束后，数组为 `[2, 3, 4, 5, 8]`。

此时，所有元素都已在正确位置，排序完成✅。示意图如下：

![img](https://bu.dusays.com/2025/09/21/68cfef843ae97.webp)

#### 核心特性

- **稳定性**：冒泡排序是稳定的排序算法，相等元素的相对位置在排序后不会改变
- **原地排序**：只需要常数级的额外空间
- **时间复杂度**：最坏和平均情况为O(n²)，最好情况为O(n)
- **比较排序**：基于元素间的比较进行排序

#### 代码实现

```java
public class BubbleSort {
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            // 每次遍历后，最大的i+1个元素已经排好序
            for (int j = 0; j < n - i - 1; j++) {
                // 如果当前元素大于下一个元素，则交换
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
    
    // 打印数组
    public static void printArray(int[] arr) {
        for (int i : arr) {
            System.out.print(i + " ");
        }
        System.out.println();
    }
    
    // 测试
    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        System.out.println("排序前的数组：");
        printArray(arr);
        
        bubbleSort(arr);
        
        System.out.println("排序后的数组：");
        printArray(arr);
    }
}

```



##### 优化版本

如果是一个已经排好序的数组，上述代码也会循环执行，我们可以针对这一点进行如下优化：

```java
public static void optimizedBubbleSort(int[] arr) {
    int n = arr.length;
    boolean swapped;
    for (int i = 0; i < n - 1; i++) {
        swapped = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }
        // 如果没有发生交换，说明数组已经有序，可以提前退出排序
        if (!swapped) {
            break;
        }
    }
}

```

#### 优缺点

##### 优点

- 代码简单，容易实现
- 适合小规模数据排序
- 对于几乎已经排好序的数据，效率较高
- 稳定的排序算法

##### 缺点

- 时间复杂度高，为O(n²)
- 随着元素数量增加，效率急剧下降
- 每次只能将一个元素移动到其最终位置，效率不高

#### 应用场景

由于效率问题，冒泡排序的应用场景比较少，不过也不是完全没有，比如：

- 教学演示：简单直观，常用于算法入门教学
- 小规模数据排序：当数据量较小、空间资源有限时可以使用
- 对于接近有序的数组：有优化版本可以在接近有序的情况下提前终止
- 嵌入式系统或资源受限环境：因为它不需要额外的内存空间

#### 扩展

##### 鸡尾酒排序（双向冒泡排序）

鸡尾酒排序是冒泡排序的一种变体，它从低到高然后从高到低来回排序，比冒泡排序的效率稍微高一点：

```java
public static void cocktailSort(int[] arr) {
    boolean swapped = true;
    int start = 0;
    int end = arr.length - 1;
    
    while (swapped) {
        // 从左到右
        swapped = false;
        for (int i = start; i < end; i++) {
            if (arr[i] > arr[i + 1]) {
                int temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
                swapped = true;
            }
        }
        
        // 如果没有交换，则已经排序完成
        if (!swapped)
            break;
            
        // 否则重置swapped标志准备从右到左
        swapped = false;
        end--;
        
        // 从右到左
        for (int i = end - 1; i >= start; i--) {
            if (arr[i] > arr[i + 1]) {
                int temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
                swapped = true;
            }
        }
        
        start++;
    }
}

```

#### 测验

1. 冒泡排序的平均时间复杂度是多少？
2. 冒泡排序是稳定的排序算法吗？
3. 对于已经排好序的数组，优化版冒泡排序的时间复杂度是多少？
4. 冒泡排序每一轮遍历后，数组尾部会有什么特点？
5. 如何优化冒泡排序以提高效率？

> 测验答案
>
> 1. 冒泡排序的平均时间复杂度是O(n²)。
> 2. 是的，冒泡排序是稳定的排序算法。因为只有当前一个元素大于后一个元素时才交换，相等元素不会改变相对位置。
> 3. 对于已经排好序的数组，优化版冒泡排序的时间复杂度是O(n)。因为第一轮遍历不会发生交换，优化版会检测到这点并提前终止。
> 4. 冒泡排序每一轮遍历后，数组尾部会有一个元素到达其最终位置，且是当前未排序部分中的最大元素。第i轮结束后，末尾i个元素已排好序。
> 5. 优化冒泡排序的方法:
>    - 添加标志位跟踪是否发生交换，无交换则提前终止
>    - 记录最后一次交换位置，下一轮只遍历到该位置
>    - 使用双向冒泡(鸡尾酒排序)，同时将最大值上浮和最小值下沉

### 二、快速排序

#### 快速排序

快速排序是一种高效的分治算法，通过选择一个基准元素，将数组分为两部分，一部分小于基准，一部分大于基准，然后递归地对两部分进行排序。

时间复杂度:最佳 O(n log n) | 平均 O(n log n) | 最差 O(n²)    空间复杂度:O(log n)

稳定性:不稳定

>##### 应用场景/前提条件
>
>- 实际应用中最常用的高效排序算法
>- 对于大多数输入可达到最佳性能
>- 缓存友好

#### 算法讲解

##### 介绍

快速排序（Quick Sort）是一种极其高效的分治排序算法，也是**实际应用中最常用的排序算法之一**。

它的核心思想可以概括为“选个基准，然后左右站队”：

1. 选基准(pivot)：首先，从数组中任意选择一个元素作为“基准”。
2. 站队：接着，重新排列数组，将所有小于基准的元素移动到基准的左边，所有大于等于基准的元素移动到右边。这一步完成后，该基准元素就找到了它在最终有序序列中的“最终位置”。
3. 分而治之：最后，对基准左右两边的子数组（现在它们是两个独立的、更小的问题），递归地重复上述过程，直到每个子数组都排序完毕。

通过这种巧妙的“分而治之”策略，快速排序能将一个大问题不断分解成小问题来解决，平均时间复杂度能达到卓越的 O(nlogn)。

#### 算法步骤

1. 从数列中选择一个元素作为"基准"，本文采用最左侧元素作为基准
2. 将所有比基准值小的元素放到基准前面，所有比基准值大的元素放到基准后面（分区操作）
3. 对基准左右两个子序列分别重复步骤1和2，直到子序列只有一个元素或为空

![img](https://bu.dusays.com/2025/09/21/68cff0855d868.webp)

#### 核心特性

- **分治策略**：将问题分解为更小的子问题，逐步解决
- **原地排序**：只需要 O(logn) 的额外空间复杂度（主要用于递归调用的栈空间）
- **时间复杂度**：平均情况为 O(nlogn)，最坏情况为 O(n²)，最好情况为 O(nlogn)
- **不稳定性**：相等元素的相对位置在排序后可能会改变
- **高效性**：在实际应用中，快速排序通常是最快的排序算法之一

#### 代码实现

```java
public class QuickSort {
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // 获取分区点位置
            int pivotIndex = partition(arr, low, high);
            
            // 递归排序左右子数组
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }
    
    private static int partition(int[] arr, int low, int high) {
        // 选择最左侧元素作为基准
        int pivot = arr[low];
        int i = low + 1;
        
        for (int j = low + 1; j <= high; j++) {
            // 将小于基准的元素移到左侧
            if (arr[j] < pivot) {
                // 交换元素
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
                i++;
            }
        }
        
        // 将基准元素放到正确位置
        int temp = arr[low];
        arr[low] = arr[i - 1];
        arr[i - 1] = temp;
        
        return i - 1;
    }
    
    // 打印数组
    public static void printArray(int[] arr) {
        for (int i : arr) {
            System.out.print(i + " ");
        }
        System.out.println();
    }
    
    // 测试
    public static void main(String[] args) {
        int[] arr = {10, 7, 8, 9, 1, 5};
        System.out.println("排序前的数组：");
        printArray(arr);
        
        quickSort(arr, 0, arr.length - 1);
        
        System.out.println("排序后的数组：");
        printArray(arr);
    }
}

```

注意，在上面的实现里，我们如下代码将小于基准的元素移到左侧：

```java
for (int j = low + 1; j <= high; j++) {
    // 将小于基准的元素移到左侧
    if (arr[j] < pivot) {
        // 交换元素
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
        i++;
    }
}

```

然后修正基准的位置，实现基准左侧都小于基准、基准右侧大于等于基准：

```java
int temp = arr[low];
arr[low] = arr[i - 1];
arr[i - 1] = temp;

```

#### 优化策略

##### 随机选择基准元素

使用最左侧元素作为基准可能会在数组已经排序或接近排序时导致最坏性能，随机选择基准可以降低这种风险:

```java
private static int randomPartition(int[] arr, int low, int high) {
    // 随机选择基准元素位置
    int randomIndex = low + (int)(Math.random() * (high - low + 1));
    
    // 将随机选择的基准元素与最左侧元素交换
    int temp = arr[randomIndex];
    arr[randomIndex] = arr[low];
    arr[low] = temp;
    
    // 使用标准分区过程
    return partition(arr, low, high);
}

```

##### 三数取中法

选择左端、中间和右端三个元素的中值作为基准，可以进一步优化快速排序：

```java
private static int medianOfThreePartition(int[] arr, int low, int high) {
    int mid = low + (high - low) / 2;
    
    // 对三个元素进行排序
    if (arr[mid] < arr[low])
        swap(arr, mid, low);
    if (arr[high] < arr[low])
        swap(arr, high, low);
    if (arr[high] < arr[mid])
        swap(arr, high, mid);
    
    // 将中值（现在在arr[mid]）放到arr[low]
    swap(arr, mid, low);
    
    // 使用标准分区过程
    return partition(arr, low, high);
}

```

#### 优缺点

##### 优点

- 平均情况下非常高效，时间复杂度为 O(nlogn)
- 原地排序，空间复杂度低
- 缓存友好，数据局部性好
- 适合处理大规模数据
- 在许多实际应用中表现优秀

##### 缺点

- 最坏情况下性能退化至 O(n²)，比如当数组已经排序时
- 不稳定的排序算法
- 对于小数组，快速排序可能比其他基础排序慢
- 递归实现可能导致栈溢出（可以使用迭代方式解决）

#### 应用场景

- 需要高效排序大量数据的情况
- 作为系统库中的排序函数（如 C++ 的 std::sort、Java 的 Arrays.sort）
- 需要就地排序且对空间复杂度敏感的场景
- 需要平均情况下高性能的应用

#### 扩展

##### 双轴快速排序

Java 的 Arrays.sort() 使用的是双轴快速排序，它使用两个枢轴(基准)，可以进一步提高性能：

```java
public static void dualPivotQuickSort(int[] arr, int low, int high) {
    if (high <= low) return;
    
    // 如果arr[low] > arr[high]，交换它们
    if (arr[low] > arr[high]) {
        int temp = arr[low];
        arr[low] = arr[high];
        arr[high] = temp;
    }
    
    // 获取两个枢轴
    int pivot1 = arr[low];
    int pivot2 = arr[high];
    
    int lt = low + 1;    // 小于pivot1的区域右边界
    int gt = high - 1;   // 大于pivot2的区域左边界
    int i = low + 1;     // 当前考察的元素
    
    while (i <= gt) {
        // 当前元素小于第一个枢轴
        if (arr[i] < pivot1) {
            int temp = arr[lt];
            arr[lt] = arr[i];
            arr[i] = temp;
            lt++;
            i++;
        } 
        // 当前元素大于第二个枢轴
        else if (arr[i] > pivot2) {
            int temp = arr[i];
            arr[i] = arr[gt];
            arr[gt] = temp;
            gt--;
        } 
        // 当前元素在两个枢轴之间
        else {
            i++;
        }
    }
    
    // 放置枢轴到正确位置
    arr[low] = arr[lt - 1];
    arr[lt - 1] = pivot1;
    
    arr[high] = arr[gt + 1];
    arr[gt + 1] = pivot2;
    
    // 递归处理三个部分
    dualPivotQuickSort(arr, low, lt - 2);
    dualPivotQuickSort(arr, lt, gt);
    dualPivotQuickSort(arr, gt + 2, high);
}

```

#### 测验

这里准备了一些测试题，方便大家判断自己的掌握情况：

1. 快速排序的平均时间复杂度是多少？
2. 快速排序是稳定的排序算法吗？
3. 使用最左侧元素作为基准的快速排序在什么情况下会出现最坏性能？
4. 快速排序的空间复杂度是多少？为什么？

> 测验答案
>
> 1. O(nlogn)。
> 2. 不是，因为基准元素的移动可能会改变相等元素的相对位置。
> 3. 当数组已经排序或接近排序时，每次分区只能减少一个元素，时间复杂度退化为O(n²)。
> 4. O(logn)，主要是递归调用占用的栈空间，最坏情况下为O(n)。

### 三、归并排序

#### 归并排序

归并排序是一种高效、分治策略的排序算法，通过递归地将数组分为两半，分别排序后再合并，以实现整体排序。

时间复杂度:最佳 O(n log n) | 平均 O(n log n) | 最差 O(n log n)    空间复杂度:O(n)

稳定性:稳定

>##### 应用场景/前提条件
>
>- 适用于大规模数据
>- 适合链表排序
>- 需要稳定性时优先选择

#### 算法讲解

##### 介绍

归并排序（Merge Sort）是一种高效且稳定的“分治”排序算法。其核心策略可以概括为“**先递归拆分，再有序合并**”。它会持续地将一个大数组对半切分，直到每个部分都只剩一个元素（此时天然有序）。接着，再反向地将这些相邻的有序部分两两配对，按大小顺序合并成一个更长的有序数组，不断重复此过程，直到最终还原成一个完整的有序序列。

归并排序的性能极其稳定，无论原始序列是好是坏，时间复杂度都保持在卓越的 O(nlogn)。与快速排序的“就地交换”不同，它通过“有序合并”实现排序，这一特性也保证了其排序的稳定性（相同元素的原始相对顺序在排序后不会改变），但通常需要额外的存储空间来辅助合并操作。

#### 算法步骤

1. 将待排序数组递归地分割成两半，直到每个子数组只包含一个元素（此时认为子数组已排序）
2. 递归地合并相邻的子数组，**合并时比较两个子数组的元素，按顺序放入临时数组**（核心）
3. 将临时数组中的元素复制回原数组对应的位置
4. 重复步骤2和3，直到所有子数组合并成一个完整的有序数组

![img](https://bu.dusays.com/2025/09/21/68cff1c3962d3.webp)

#### 核心特性

- **分治策略**：将问题分解为更小的子问题，再将子问题的解合并
- **稳定排序**：相等元素的相对位置在排序后不会改变
- **时间复杂度**：最好、最坏、平均情况均为 O(nlogn)
- **空间复杂度**：需要 O(n) 的额外空间
- **非原地排序**：需要额外空间来存储临时数组

#### 代码实现

```java
public class MergeSort {
    public static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            // 找出中间点
            int mid = left + (right - left) / 2;
            
            // 递归排序左右两半
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            
            // 合并已排序的两半
            merge(arr, left, mid, right);
        }
    }
    
    private static void merge(int[] arr, int left, int mid, int right) {
        // 计算两个子数组的大小
        int n1 = mid - left + 1;
        int n2 = right - mid;
        
        // 创建临时数组
        int[] L = new int[n1];
        int[] R = new int[n2];
        
        // 复制数据到临时数组
        for (int i = 0; i < n1; i++)
            L[i] = arr[left + i];
        for (int j = 0; j < n2; j++)
            R[j] = arr[mid + 1 + j];
        
        // 合并临时数组
        int i = 0, j = 0;
        int k = left;
        
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }
        
        // 复制L[]的剩余元素
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }
        
        // 复制R[]的剩余元素
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }
    
    // 打印数组
    public static void printArray(int[] arr) {
        for (int i : arr) {
            System.out.print(i + " ");
        }
        System.out.println();
    }
    
    // 测试
    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6, 7};
        System.out.println("排序前的数组：");
        printArray(arr);
        
        mergeSort(arr, 0, arr.length - 1);
        
        System.out.println("排序后的数组：");
        printArray(arr);
    }
}

```

注意，在上述代码里，通过：

```java
// 合并临时数组
int i = 0, j = 0;
int k = left;

while (i < n1 && j < n2) {
    if (L[i] <= R[j]) {
        arr[k] = L[i];
        i++;
    } else {
        arr[k] = R[j];
        j++;
    }
    k++;
}

```

实现了归并排序最关键的合并过程，将两个有序子数组合并成一个更大的有序数组。

```java
function mergeSort(arr, left = 0, right = arr.length - 1) {
    if (left < right) {
        // 找出中间点
        const mid = Math.floor(left + (right - left) / 2);
        
        // 递归排序左右两半
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        
        // 合并已排序的两半
        merge(arr, left, mid, right);
    }
    
    return arr;
}

function merge(arr, left, mid, right) {
    // 计算两个子数组的大小
    const n1 = mid - left + 1;
    const n2 = right - mid;
    
    // 创建临时数组
    const L = new Array(n1);
    const R = new Array(n2);
    
    // 复制数据到临时数组
    for (let i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (let j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];
    
    // 合并临时数组
    let i = 0, j = 0;
    let k = left;
    
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    
    // 复制L的剩余元素
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    
    // 复制R的剩余元素
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// 测试
const arr = [12, 11, 13, 5, 6, 7];
console.log("排序前：", arr);
mergeSort(arr);
console.log("排序后：", arr);

```

#### 优化策略

##### 小规模数组使用插入排序

当子数组规模较小时，可以使用插入排序代替递归，提高效率：

```java
private static void mergeSort(int[] arr, int left, int right) {
    // 当数组长度小于等于INSERTION_SORT_THRESHOLD时使用插入排序
    if (right - left <= INSERTION_SORT_THRESHOLD) {
        insertionSort(arr, left, right);
        return;
    }
    
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

private static void insertionSort(int[] arr, int left, int right) {
    for (int i = left + 1; i <= right; i++) {
        int key = arr[i];
        int j = i - 1;
        
        while (j >= left && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        arr[j + 1] = key;
    }
}

```

##### 避免不必要的复制

如果第一个子数组的最大元素小于等于第二个子数组的最小元素，那么无需合并，直接返回：

```java
▼Java复制代码private static void merge(int[] arr, int left, int mid, int right) {
    // 如果arr[mid] <= arr[mid+1]，数组已经有序，无需合并
    if (arr[mid] <= arr[mid + 1]) {
        return;
    }
    
    // 常规合并过程
    // ...
}
```

#### 优缺点

##### 优点

- 时间复杂度稳定，在最好、最坏和平均情况下均为 O(nlogn)
- 稳定排序算法，保持相等元素的相对顺序
- 适合处理大规模数据，尤其是外部排序
- 可以改造为并行算法，提高效率

##### 缺点

- 需要 O(n) 的额外空间
- 对于小规模数据，递归开销较大
- 不是原地排序算法，空间效率不如快速排序等
- 在一些情况下，常数因子较大，实际性能可能不如快速排序

> 算法复杂度中的 O(n logn)，只是**忽略了常数因子**的量级分析。但是在实际情况中，**常数因子 + 实际操作成本**对性能影响很大。
>
> 归并排序中的常数因子主要来自：
>
> 1. **大量的内存复制操作（额外空间）**
>
> - 每次合并子数组时，都需要将两个子数组复制到一个临时数组，再合并写回原数组。
> - 这会造成大量内存分配和数据拷贝，带来不小的开销。
> - 在缓存局部性（CPU cache）方面也不如快速排序高效。
>
> 1. **空间复杂度 O(n)**
>
> 每一层递归合并都需要额外的数组，增加内存占用且可能导致更多的 GC（垃圾回收）。
>
> 1. **递归调用多、函数开销高**
>
> 递归深度为 logn，每一层都会处理大量数组复制和合并操作。函数调用开销 + 合并逻辑相对复杂，会导致性能下降。

#### 应用场景

1）需要稳定排序时（保持相等元素的相对顺序）

2）外部排序，当数据量太大无法全部装入内存

3）逆序对计数等特殊问题

4）对数据稳定性要求高的企业级应用

> 什么是“逆序对”？
>
> 在一个数组中，如果有一对下标 (i, j) 满足：
>
> i < j 且 nums[i] > nums[j]
>
> 那么这一对就叫做一个逆序对（Inversion Pair）。
>
> 示例：
>
> 数组：nums = [7, 5, 6, 4]
>
> 逆序对有 (7,5)、(7,6)、(7,4)、(5,4)、(6,4) 共 5 个

5）适合链表等顺序存储结构的排序

#### 扩展

##### 外部归并排序

数据量大到无法全部装入内存的时候，可以使用外部归并排序：

1. 将大文件分割成多个能载入内存的小文件
2. 对每个小文件单独排序
3. 将排序好的小文件归并成大文件

```java
▼Java复制代码public static void externalMergeSort(String inputFile, String outputFile, int chunkSize) {
    // 第一步：分割文件并排序各个块
    List<String> chunkFiles = splitAndSort(inputFile, chunkSize);
    
    // 第二步：归并排序文件
    mergeFiles(chunkFiles, outputFile);
}
```

##### 多路归并

通过多路归并进一步优化合并过程，尤其是在外部排序里：

```java
▼Java复制代码public static void multiWayMerge(List<String> inputFiles, String outputFile) {
    // 创建优先队列，存储每个文件的当前元素
    PriorityQueue<FileEntry> pq = new PriorityQueue<>();
    
    // 为每个输入文件打开一个读取器
    // 将每个文件的第一个元素添加到优先队列
    
    // 循环直到优先队列为空
    // 每次取出最小元素，写入输出文件，并从相应文件读取下一个元素
}
```

#### 测验

这里准备了一些测试题，方便大家判断自己的掌握情况：

1. 归并排序的最好、最坏和平均时间复杂度分别是多少？
2. 归并排序的空间复杂度是多少？
3. 归并排序与快速排序相比有哪些优缺点？

> 测验答案
>
> 1. 最好、最坏和平均时间复杂度均为 O(nlogn)。
> 2. O(n)，需要额外空间来存储临时数组。
> 3. 优点：时间复杂度稳定，是稳定排序。缺点：需要额外空间，不是原地排序。

### 四、插入排序

#### 插入排序

插入排序是一种简单且高效的排序算法，它通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

时间复杂度:最佳 O(n) | 平均 O(n²) | 最差 O(n²)   空间复杂度:O(1)

稳定性:稳定

>##### 应用场景/前提条件
>
>- 适用于小规模数据
>- 对几乎已排序的数据非常高效
>- 数据流实时排序

#### 算法讲解

##### 介绍

插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作方式类似于我们打牌时的整理牌序，它将待排序序列分为两部分：已排序部分和未排序部分。算法不断地从未排序部分取出元素，然后插入到已排序部分的正确位置，直到所有元素都排序完毕。

#### 算法步骤

1. 将第一个元素视为已排序序列，其余元素视为未排序序列
2. 从未排序序列中取出第一个元素，称为"待插入元素"
3. 从已排序序列的末尾开始，依次与待插入元素比较
4. 如果已排序序列中的元素大于待插入元素，则将该元素后移一位
5. 重复步骤3和4，直到找到小于或等于待插入元素的位置
6. 将待插入元素插入到该位置
7. 重复步骤2至6，直到未排序序列为空

为了帮助大家更好的理解，我们以初始数组 `[5, 2, 4, 6, 1, 3]` 为例，查看每一步的详细流程：

------

- 初始状态： 默认第一个元素 `5` 为已排序部分。
- 第一轮：
  - 待插入元素：`2`
  - 过程： 将 `2` 与已排序的 `5` 比较，`2 < 5`，因此 `5` 向右移动，`2` 插入到 `5` 的前面。
  - 结果：`[2, 5, 4, 6, 1, 3]`。已排序部分为 `[2, 5]`。
- 第二轮：
  - 待插入元素：`4`
  - 过程： 将 `4` 与已排序的 `5` 比较，`4 < 5`，`5` 右移；再与 `2` 比较，`4 > 2`，故 `4` 插入到 `2` 的后面。
  - 结果：`[2, 4, 5, 6, 1, 3]`。已排序部分为 `[2, 4, 5]`。
- 第三轮：
  - 待插入元素：`6`
  - 过程： 将 `6` 与已排序的 `5` 比较，`6 > 5`，说明 `6` 的位置就在当前已排序部分的末尾，无需移动。
  - 结果：`[2, 4, 5, 6, 1, 3]`。已排序部分为 `[2, 4, 5, 6]`。
- 第四轮：
  - 待插入元素：`1`
  - 过程： 将 `1` 依次与 `6`, `5`, `4`, `2` 比较，因 `1` 是最小的，所有已排序元素均向右移动，`1` 插入到数组开头。
  - 结果：`[1, 2, 4, 5, 6, 3]`。已排序部分为 `[1, 2, 4, 5, 6]`。
- 第五轮：
  - 待插入元素：`3`
  - 过程： 将 `3` 依次与 `6`, `5`, `4` 比较，它们都向右移动；再与 `2` 比较，`3 > 2`，故 `3` 插入到 `2` 的后面。
  - 结果：`[1, 2, 3, 4, 5, 6]`。数组全部排序完成。

![img](https://bu.dusays.com/2025/09/21/68cff347c5562.webp)

#### 核心特性

- 稳定性：稳定的排序算法，相等元素的相对位置在排序后不会改变
- 原地排序：只需要常数级的额外空间
- 时间复杂度：最坏和平均情况为O(n²)，最好情况为O(n)
- 适应性：对于部分有序的数组，插入排序的效率更高
- 增量处理：可以在排序过程中实时加入新元素

#### 代码实现

```java
public class InsertionSort {
    public static void insertionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            int key = arr[i]; // 当前待插入元素
            int j = i - 1;
            
            // 将大于key的元素向后移动
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j = j - 1;
            }
            
            // 找到key的正确位置，插入
            arr[j + 1] = key;
        }
    }
    
    // 打印数组
    public static void printArray(int[] arr) {
        for (int i : arr) {
            System.out.print(i + " ");
        }
        System.out.println();
    }
    
    // 测试
    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6};
        System.out.println("排序前的数组：");
        printArray(arr);
        
        insertionSort(arr);
        
        System.out.println("排序后的数组：");
        printArray(arr);
    }
}

```

##### 二分查找优化

在原来的基础上，可以使用二分查找来加速寻找插入位置的过程，减少比较次数：

```java
public static void binaryInsertionSort(int[] arr) {
    int n = arr.length;
    
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int left = 0;
        int right = i - 1;
        
        // 使用二分查找找到插入位置
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] > key) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        // 将元素后移
        for (int j = i - 1; j >= left; j--) {
            arr[j + 1] = arr[j];
        }
        
        // 插入元素
        arr[left] = key;
    }
}

```

#### 优缺点

##### 优点

- 算法实现简单，容易理解
- 对于小规模数据或基本有序的数据效率较高
- 稳定的排序算法
- 适合增量式排序（可以一边插入元素一边保持有序）
- 对于接近有序的数组，时间复杂度接近O(n)

##### 缺点

- 对于大规模乱序数组，时间复杂度为O(n²)，效率较低
- 需要较多的元素移动操作
- 不适合对倒序或接近倒序的数组进行排序

#### 应用场景

- 数据规模较小的排序任务
- 对几乎已经排好序的数据进行排序
- 在线算法场景：数据是实时到达的，需要动态地将新元素插入到已排序的序列中
- 嵌入式系统或资源受限环境
- 作为更复杂排序算法（如希尔排序）的基础

#### 扩展

##### 希尔排序：插入排序的改进版

希尔排序是对插入排序的改进版本，更加高效，它的原理是比较相距一定间隔的元素，逐步减小间隔直到为1，此时数组已基本有序，再进行一次插入排序：

```java
▼Java复制代码public static void shellSort(int[] arr) {
    int n = arr.length;
    
    // 初始间隔设为n/2，每次减半
    for (int gap = n/2; gap > 0; gap /= 2) {
        // 对每个间隔进行插入排序
        for (int i = gap; i < n; i++) {
            int temp = arr[i];
            int j;
            
            // 对间隔为gap的元素进行插入排序
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                arr[j] = arr[j - gap];
            }
            
            arr[j] = temp;
        }
    }
}
```

#### 测验

这里准备了一些测试题，方便大家判断自己的掌握情况：

1. 插入排序的平均时间复杂度是多少？
2. 插入排序是稳定的排序算法吗？
3. 插入排序最适合什么类型的数据？
4. 二分插入排序相比基本插入排序有什么改进？

> 测验答案
>
> 1. O(n²) 。
> 2. 是的，因为只有当待插入元素小于已排序序列中的元素时才会移动，相等元素不会改变相对位置。
> 3. 小规模数据和几乎已经排好序的数据，在这些情况下，插入排序可以达到** 接近O(n) **的时间复杂度。
> 4. 二分插入排序使用二分查找来快速定位待插入元素的正确位置，减少了比较次数，但移动元素的操作次数不变。

### 五、选择排序

#### 选择排序

选择排序是一种简单直观的排序算法，它通过重复从未排序部分选择最小元素，放入已排序部分的末尾，逐步构建有序序列。每轮只需一次交换，交换次数最少。

时间复杂度:最佳 O(n²) | 平均 O(n²) | 最差 O(n²)    空间复杂度:O(1)

稳定性:不稳定

>##### 应用场景/前提条件
>
>- 适用于小规模数据
>- 对数据移动较少的情况效率较高

#### 算法讲解

##### 介绍

择排序是一种非常简单直观的排序算法，工作原理可以概括为“**每次从未排序的队伍中，选出最优者，让它归位**”。具体来说，算法在每一轮都会遍历所有还未排序的元素，从中找出最小（或最大）的一个，然后将其与未排序部分的第一个元素交换位置。这个操作能确保每一轮过后，都有一个元素被精准地放在它最终的正确位置上。接着，算法会缩小范围，在剩下的元素中重复这个“选择与交换”的过程，直到整个序列完全有序。

#### 算法步骤

1. 首先在未排序序列中找到最小（或最大）元素，存放到排序序列的起始位置
2. 再从剩余未排序元素中继续寻找最小（或最大）元素，然后放到未排序部分的起始位置
3. 重复步骤2，直到所有元素均排序完毕

为了帮助大家更好的理解，我们以初始数组 `[64, 25, 12, 22, 11]` 为例，查看每一步的详细流程：

1. 第一轮：找到全局最小值 `11`，与首位 `64` 交换。数组变为 `[11, 25, 12, 22, 64]`。
2. 第二轮：在剩余部分 `[25, 12, 22, 64]` 中找到最小值 `12`，与当前首位 `25` 交换。数组变为 `[11, 12, 25, 22, 64]`。
3. 第三轮：在剩余部分 `[25, 22, 64]` 中找到最小值 `22`，与当前首位 `25` 交换。数组变为 `[11, 12, 22, 25, 64]`。
4. 第四轮：在剩余部分 `[25, 64]` 中找到最小值 `25`，它已在正确位置，无需交换。

![img](https://bu.dusays.com/2025/09/21/68cff3f7e4044.webp)

#### 核心特性

- **稳定性**：选择排序是不稳定的排序算法，它可能会改变相等元素的相对位置
- **原地排序**：只需要常数级的额外空间
- **时间复杂度**：最好、最坏和平均情况均为 O(n²)
- **比较排序**：基于元素间的比较进行排序
- **交换次数少**：最多进行 `n-1` 次交换，比冒泡排序的交换次数要少

#### 代码实现

```java
public class SelectionSort {
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        
        // 遍历数组
        for (int i = 0; i < n - 1; i++) {
            // 找出从i到n-1中最小值的索引
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }

            if (i != minIndex) {
                // 将找到的最小值与当前位置i交换
                int temp = arr[minIndex];
                arr[minIndex] = arr[i];
                arr[i] = temp;
            }
        }
    }
    
    // 打印数组
    public static void printArray(int[] arr) {
        for (int i : arr) {
            System.out.print(i + " ");
        }
        System.out.println();
    }
    
    // 测试
    public static void main(String[] args) {
        int[] arr = {64, 25, 12, 22, 11};
        System.out.println("排序前的数组：");
        printArray(arr);
        
        selectionSort(arr);
        
        System.out.println("排序后的数组：");
        printArray(arr);
    }
}

```

#### 优缺点

##### 优点

- 实现简单，思路清晰
- 交换操作的次数比冒泡排序少，平均性能比冒泡排序好
- 对于小规模的数据效率还算可以
- 不占用额外内存空间

##### 缺点

- 时间复杂度固定为 O(n²) ，无论输入数据如何都要扫描全部未处理的元素
- 不稳定的排序算法，可能会改变相同元素的相对位置
- 当数据量较大时，效率低下

#### 应用场景

选择排序虽然效率不高，但在某些特定场景下仍有一些应用场景，跟冒泡排序类似：

- 数据规模较小的排序场景
- 对交换操作开销较大的排序场景（选择排序的交换次数少）
- 内存空间有限的嵌入式系统
- 算法教学和入门学习

#### 扩展

##### 双向选择排序

双向选择排序是选择排序的一种变体，每轮同时选出最小值和最大值，分别放到序列的两端：

```java
▼Java复制代码public static void bidirectionalSelectionSort(int[] arr) {
    int left = 0;
    int right = arr.length - 1;
    
    while (left < right) {
        int minIndex = left;
        int maxIndex = left;
        
        // 在当前未排序区间找出最小值和最大值的索引
        for (int i = left + 1; i <= right; i++) {
            if (arr[i] < arr[minIndex]) {
                minIndex = i;
            }
            if (arr[i] > arr[maxIndex]) {
                maxIndex = i;
            }
        }
        
        // 将最小值交换到左边
        if (minIndex != left) {
            int temp = arr[left];
            arr[left] = arr[minIndex];
            arr[minIndex] = temp;
            
            // 如果最大值的索引恰好是left，交换后最大值现在在minIndex位置
            if (maxIndex == left) {
                maxIndex = minIndex;
            }
        }
        
        // 将最大值交换到右边
        if (maxIndex != right) {
            int temp = arr[right];
            arr[right] = arr[maxIndex];
            arr[maxIndex] = temp;
        }
        
        left++;
        right--;
    }
}
```

#### 测验

1. 选择排序的平均时间复杂度是多少？
2. 选择排序是稳定的排序算法吗？为什么？
3. 选择排序相比冒泡排序的主要优势是什么？
4. 选择排序每一轮遍历后，数组前端会有什么特点？
5. 对于优化选择排序，你有哪些思路？

> 测验答案
>
> 1. 选择排序的平均时间复杂度是 O(n²)。
> 2. 选择排序是不稳定的排序算法。因为交换操作可能会改变相等元素的相对顺序。例如，在数组[5, 5, 2]中，第一个5可能会与2交换位置，导致两个5的相对位置发生变化。
> 3. 选择排序相比冒泡排序的主要优势是交换次数更少，最多进行 n-1 次交换，而冒泡排序在最坏情况下需要 O(n²) 次交换。
> 4. 每一轮会有一个元素到达其最终位置，且是当前未排序部分中的最小元素。第i轮结束后，前i个元素已经排好序了。
> 5. 优化选择排序的方法:
>    - 使用双向选择排序，同时查找最大值和最小值
>    - 使用二元选择排序，减少比较次数
>    - 结合堆数据结构（变成堆排序）降低时间复杂度

### 六、堆排序

#### 堆排序

堆排序是一种基于比较的高效排序算法，它利用堆这种数据结构的特性进行排序，通过建立最大堆，不断取出最大元素并调整堆来实现排序。

时间复杂度:最佳 O(n log n) | 平均 O(n log n) | 最差 O(n log n)   空间复杂度:O(1)

稳定性:不稳定

>##### 应用场景/前提条件
>
>- 对大规模数据效率高
>- 不需要额外空间
>- 保证最坏情况时间复杂度为O(n log n)

#### 算法讲解

##### 介绍

堆排序（Heap Sort）是一种高效的原地排序算法，它巧妙地利用了“堆”数据结构。其核心思想是首先将待排序的数组重构成一个最大堆（Max Heap）。在最大堆中，根节点（数组的第一个元素）始终是所有元素中的最大值。

构建好最大堆后，算法将堆顶的最大元素与堆末尾的元素交换，从而将当前的最大值放置到数组的正确最终位置。接着，将堆的大小减一，并对剩余的元素进行“堆化”调整，确保新的根节点仍然是剩余元素中的最大值。此过程不断重复——交换、缩小堆、重新堆化——直到所有元素都被放置到其最终的有序位置，完成整个排序。

> 堆（Heap）是一种特殊的完全二叉树结构，它的两个重要特性：
>
> - 堆是一个完全二叉树，除了最底层外，其他层的节点都是满的，最底层的节点从左到右填充。
> - 在最大堆中，每个节点的值都大于或等于其子节点的值；在最小堆中，每个节点的值都小于或等于其子节点的值。
>
> 堆的数组表示：
>
> 虽然堆是一种树结构，但是也可以用数组高效地表示，这是堆的一个重要特性。
>
> 对于数组中索引为 i 的节点：
>
> 其左子节点的索引为 2*i + 1
>
> 其右子节点的索引为 2*i + 2
>
> 这种表示方法非常紧凑，不需要使用额外的指针，充分利用了完全二叉树的性质。

#### 算法步骤

1. 将无序序列构建成一个最大堆
2. 将堆顶元素（最大值）与堆的最后一个元素交换
3. 剔除最后一个元素（已排序），将剩余元素重新构建为最大堆
4. 重复步骤2和3，直到堆中只剩下一个元素

![img](https://bu.dusays.com/2025/09/21/68cff4a091b76.webp)![img](https://bu.dusays.com/2025/09/21/68cff4a0a39de.webp)

#### 核心特性

- **堆数据结构**：利用完全二叉树的性质，可以用数组高效表示
- **原地排序**：只需要常数级的额外空间
- **时间复杂度**：建堆时间为O(n)，排序时间为O(nlogn)，总体时间复杂度为O(nlogn)
- **不稳定性**：相等元素的相对位置在排序后可能会改变
- **自适应性**：对于部分有序或完全无序的数据，性能比较稳定

#### 代码实现

```java
public class HeapSort {
    public static void heapSort(int[] arr) {
        int n = arr.length;
        
        // 构建最大堆
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        // 逐个从堆顶取出元素
        for (int i = n - 1; i > 0; i--) {
            // 将当前堆顶（最大值）移到末尾
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            
            // 对剩余元素重新构建最大堆
            heapify(arr, i, 0);
        }
    }
    
    // 调整以root为根的子树为最大堆
    private static void heapify(int[] arr, int n, int root) {
        int largest = root;      // 初始化最大值为根节点
        int left = 2 * root + 1; // 左子节点
        int right = 2 * root + 2; // 右子节点
        
        // 如果左子节点大于根节点
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        // 如果右子节点大于当前最大值
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        // 如果最大值不是根节点
        if (largest != root) {
            // 交换根节点和最大值
            int swap = arr[root];
            arr[root] = arr[largest];
            arr[largest] = swap;
            
            // 递归调整被影响的子树
            heapify(arr, n, largest);
        }
    }
    
    // 打印数组
    public static void printArray(int[] arr) {
        for (int i : arr) {
            System.out.print(i + " ");
        }
        System.out.println();
    }
    
    // 测试
    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6, 7};
        System.out.println("排序前的数组：");
        printArray(arr);
        
        heapSort(arr);
        
        System.out.println("排序后的数组：");
        printArray(arr);
    }
}

```

这段代码中，`heapify`函数是堆排序的核心，负责构建最大堆。

```javascript
function heapSort(arr) {
    const n = arr.length;
    
    // 构建最大堆
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    // 逐个从堆顶取出元素
    for (let i = n - 1; i > 0; i--) {
        // 将当前堆顶（最大值）移到末尾
        [arr[0], arr[i]] = [arr[i], arr[0]];
        
        // 对剩余元素重新构建最大堆
        heapify(arr, i, 0);
    }
    
    return arr;
}

function heapify(arr, n, root) {
    let largest = root;      // 初始化最大值为根节点
    const left = 2 * root + 1; // 左子节点
    const right = 2 * root + 2; // 右子节点
    
    // 如果左子节点大于根节点
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    
    // 如果右子节点大于当前最大值
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    
    // 如果最大值不是根节点
    if (largest !== root) {
        // 交换根节点和最大值
        [arr[root], arr[largest]] = [arr[largest], arr[root]];
        
        // 递归调整被影响的子树
        heapify(arr, n, largest);
    }
}

// 测试
const arr = [12, 11, 13, 5, 6, 7];
console.log("排序前：", arr);
heapSort(arr);
console.log("排序后：", arr);

```

#### 优化策略

##### 非递归实现

递归调用`heapify`可能在大规模数据时导致栈溢出，可以使用迭代方式实现：

```java
▼Java复制代码private static void heapifyIterative(int[] arr, int n, int root) {
    int largest = root;
    boolean keepGoing = true;
    
    while (keepGoing) {
        int left = 2 * largest + 1;
        int right = 2 * largest + 2;
        int maxIndex = largest;
        
        if (left < n && arr[left] > arr[maxIndex]) {
            maxIndex = left;
        }
        
        if (right < n && arr[right] > arr[maxIndex]) {
            maxIndex = right;
        }
        
        if (maxIndex != largest) {
            int temp = arr[largest];
            arr[largest] = arr[maxIndex];
            arr[maxIndex] = temp;
            
            largest = maxIndex;
        } else {
            keepGoing = false;
        }
    }
}
```

##### 堆排序的自适应版本

也可以通过记录每次下滑操作的深度，减少不必要的比较：

```java
▼Java复制代码private static void adaptiveHeapify(int[] arr, int n, int root) {
    int item = arr[root];
    int i = root;
    
    while (i < n/2) {
        int child = 2*i + 1;
        
        // 选择较大的子节点
        if (child+1 < n && arr[child] < arr[child+1]) {
            child++;
        }
        
        // 如果子节点大于item，继续下滑
        if (item < arr[child]) {
            arr[i] = arr[child];
            i = child;
        } else {
            break;
        }
    }
    
    arr[i] = item;
}
```

#### 优缺点

##### 优点

- 时间复杂度稳定，最好、最坏、平均情况均为O(nlogn)
- 原地排序，空间复杂度为O(1)
- 可以用于实现优先队列
- 适合处理大规模数据
- 不受输入数据分布影响，性能稳定

##### 缺点

- 不是稳定的排序算法
- 在实际应用中，常数因子较大，可能比快速排序慢
- 对缓存不够友好，数据访问的局部性不好
- 实现复杂度较高，特别是构建堆的部分

#### 应用场景

- 需要保证最坏情况时间复杂度的场景
- 实现优先队列（Priority Queue）
- 需要找出序列中最大或最小的k个元素
- 定时器系统中的事件调度

#### 扩展

##### 使用堆实现优先队列

堆数据结构本身是实现优先队列的理想选择：

```java
▼Java复制代码public class PriorityQueue {
    private int[] heap;
    private int size;
    private int capacity;
    
    public PriorityQueue(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.heap = new int[capacity];
    }
    
    public void insert(int value) {
        if (size >= capacity) {
            throw new IllegalStateException("队列已满");
        }
        
        int current = size++;
        heap[current] = value;
        
        // 上浮操作，维护堆的性质
        while (current > 0) {
            int parent = (current - 1) / 2;
            if (heap[current] <= heap[parent]) {
                break;
            }
            
            int temp = heap[current];
            heap[current] = heap[parent];
            heap[parent] = temp;
            
            current = parent;
        }
    }
    
    public int extractMax() {
        if (size <= 0) {
            throw new IllegalStateException("队列为空");
        }
        
        int max = heap[0];
        heap[0] = heap[--size];
        
        // 下沉操作，维护堆的性质
        heapify(heap, size, 0);
        
        return max;
    }
    
    // heapify方法同上...
}
```

##### TopK问题

使用堆排序解决TopK问题（找出数组中最大/最小的K个数）：

```java
▼Java复制代码public static int[] findTopK(int[] arr, int k) {
    if (k <= 0 || k > arr.length) {
        throw new IllegalArgumentException("无效的k值");
    }
    
    int[] result = new int[k];
    
    // 构建大小为k的最小堆
    // 这里使用数组前k个元素构建初始堆
    int[] minHeap = new int[k];
    System.arraycopy(arr, 0, minHeap, 0, k);
    
    for (int i = k/2 - 1; i >= 0; i--) {
        minHeapify(minHeap, k, i);
    }
    
    // 遍历剩余元素
    for (int i = k; i < arr.length; i++) {
        // 如果当前元素大于堆顶，替换堆顶并重新调整堆
        if (arr[i] > minHeap[0]) {
            minHeap[0] = arr[i];
            minHeapify(minHeap, k, 0);
        }
    }
    
    // 将堆中元素复制到结果数组
    System.arraycopy(minHeap, 0, result, 0, k);
    
    return result;
}

private static void minHeapify(int[] arr, int n, int i) {
    int smallest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    if (left < n && arr[left] < arr[smallest]) {
        smallest = left;
    }
    
    if (right < n && arr[right] < arr[smallest]) {
        smallest = right;
    }
    
    if (smallest != i) {
        int temp = arr[i];
        arr[i] = arr[smallest];
        arr[smallest] = temp;
        
        minHeapify(arr, n, smallest);
    }
}
```

#### 测验

这里准备了一些测试题，方便大家判断自己的掌握情况：

1. 堆排序的时间复杂度是多少？
2. 堆排序是稳定的排序算法吗？
3. 在堆中，父节点的索引与子节点索引有什么关系？
4. 堆排序的空间复杂度是多少？

> 测验答案
>
> 1. O(nlogn)，在最好、最坏和平均情况下都是。
> 2. 不是。
> 3. 对于一个索引为i的节点，其左子节点索引为2i+1，右子节点索引为2i+2。
> 4. O(1)，是一种原地排序算法。

### 七、计数排序

#### 计数排序

计数排序是一种非比较型的排序算法，适用于数据范围较小的情况，它通过统计元素出现的次数来进行排序。

时间复杂度:最佳 O(n + k) | 平均 O(n + k) | 最差 O(n + k)  空间复杂度:O(n + k)

稳定性:稳定

>##### 应用场景/前提条件
>
>- 仅适用于整数
>- 适用于数据范围较小的情况
>- 非比较型排序算法

#### 算法讲解

##### 介绍

计数排序（Counting Sort）是一种非比较型的排序算法，核心思想是通过统计元素出现的次数进行排序，利用数组的索引来确定元素的正确位置。

计数排序特别适合于已知范围不大的整数序列排序，其时间复杂度为 O(n+k)，其中 n 是待排序数组的长度，k 是整数的范围。当 k 不是很大时，计数排序可以实现线性时间排序，这是基于比较的排序算法（快速排序、归并排序等）无法达到的。

#### 算法步骤

1. 找出待排序数组中的最大值和最小值，确定计数数组的大小
2. 创建一个计数数组，统计每个元素出现的次数
3. 对计数数组进行累加，得到每个元素在排序后数组中的位置
4. 创建一个临时数组，从后向前扫描原数组，根据计数数组确定元素位置
5. 将临时数组复制回原数组

![img](https://algo.codefather.cn/algorithms/sorting/需要计数排序流程图)![img](https://bu.dusays.com/2025/09/21/68cff60ce290d.webp)

![img](https://bu.dusays.com/2025/09/21/68cff60cb8e00.webp)

#### 核心特性

- 非比较排序：不通过比较元素大小进行排序
- 稳定排序：相等元素的相对位置在排序后不会改变
- 时间复杂度：O(n+k)，其中 k 是数据范围
- 空间复杂度：O(n+k)，需要额外空间存储计数数组和临时数组
- 适用范围：整数且范围较小的数据集

#### 代码实现

```java
public class CountingSort {
    public static void countingSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        // 找出数组中的最大值和最小值
        int max = arr[0], min = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
            if (arr[i] < min) {
                min = arr[i];
            }
        }
        
        // 计算计数数组的大小
        int range = max - min + 1;
        
        // 创建计数数组并统计每个元素出现的次数
        int[] count = new int[range];
        for (int i = 0; i < arr.length; i++) {
            count[arr[i] - min]++;
        }
        
        // 计算累加数组，确定每个元素在排序后的位置
        for (int i = 1; i < range; i++) {
            count[i] += count[i - 1];
        }
        
        // 创建临时数组存储排序结果
        int[] output = new int[arr.length];
        
        // 从后往前遍历原数组，保证排序的稳定性
        for (int i = arr.length - 1; i >= 0; i--) {
            output[count[arr[i] - min] - 1] = arr[i];
            count[arr[i] - min]--;
        }
        
        // 将排序结果复制回原数组
        for (int i = 0; i < arr.length; i++) {
            arr[i] = output[i];
        }
    }
    
    // 打印数组
    public static void printArray(int[] arr) {
        for (int i : arr) {
            System.out.print(i + " ");
        }
        System.out.println();
    }
    
    // 测试
    public static void main(String[] args) {
        int[] arr = {4, 2, 2, 8, 3, 3, 1};
        System.out.println("排序前的数组：");
        printArray(arr);
        
        countingSort(arr);
        
        System.out.println("排序后的数组：");
        printArray(arr);
    }
}

```

计数排序最关键的操作是从后向前扫描保证排序的稳定性，相同的元素在排序后相对顺序不变：

```java
// 从后往前遍历原数组，保证排序的稳定性
for (int i = arr.length - 1; i >= 0; i--) {
    output[count[arr[i] - min] - 1] = arr[i];
    count[arr[i] - min]--;
}

```

#### 优化策略

##### 处理负数和极大范围

当数据范围很大或包含负数时，标准计数排序可能面临问题，可以进行如下优化：

```java
▼Java复制代码public static void countingSortForLargeRange(int[] arr) {
    // 找出数组中的最大值和最小值
    int max = arr[0], min = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
        if (arr[i] < min) {
            min = arr[i];
        }
    }
    
    // 计算范围
    int range = max - min + 1;
    
    // 如果范围过大，可以考虑使用其他排序算法
    if (range > arr.length * 100) {
        // 这里可以调用其他排序算法，如快速排序
        Arrays.sort(arr);
        return;
    }
    
    // 正常的计数排序逻辑
    // ...
}
```

##### 内存优化

当只需要排序结果、不需要保持稳定性时，可以省略输出数组，直接更新原数组：

```java
▼Java复制代码public static void countingSortInPlace(int[] arr) {
    // 找出最大值和最小值
    int max = arr[0], min = arr[0];
    for (int i = 1; i < arr.length; i++) {
        max = Math.max(max, arr[i]);
        min = Math.min(min, arr[i]);
    }
    
    // 创建计数数组
    int[] count = new int[max - min + 1];
    for (int i = 0; i < arr.length; i++) {
        count[arr[i] - min]++;
    }
    
    // 直接从计数数组重建原数组
    int index = 0;
    for (int i = 0; i < count.length; i++) {
        while (count[i] > 0) {
            arr[index++] = i + min;
            count[i]--;
        }
    }
}
```

#### 优缺点

##### 优点

- 时间复杂度为 O(n+k)，当 k 不大时可以达到线性时间
- 稳定排序算法
- 适合对整数进行排序
- 不需要比较元素，对于范围小的数据集非常高效

##### 缺点

- 只适用于整数排序
- 当数据范围 k 很大时，空间复杂度高
- 不适合对浮点数、字符串等进行排序（需要额外转换）
- 对于数据分布极不均匀的情况效率低下

#### 应用场景

计数排序比较适合数据范围较小且是整数的排序场景，尤其是元素分布集中、重复值较多的情况：

1）用于对范围较小的整数进行排序，如年龄、分数等

3）对于需要重复计数或统计数据的场景（如直方图统计）

4）对于要求稳定排序且元素为整数的场景

5）用于计算特定范围内元素的分布统计

#### 扩展

##### 基数排序结合

计数排序可以作为基数排序的子过程，处理每一位的排序：

```java
▼Java复制代码public static void radixSort(int[] arr) {
    // 找出最大值
    int max = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    
    // 对每一位数字进行计数排序
    for (int exp = 1; max / exp > 0; exp *= 10) {
        countingSortByDigit(arr, exp);
    }
}

private static void countingSortByDigit(int[] arr, int exp) {
    int[] output = new int[arr.length];
    int[] count = new int[10]; // 一位数字范围是0-9
    
    // 统计当前位上每个数字出现的次数
    for (int i = 0; i < arr.length; i++) {
        count[(arr[i] / exp) % 10]++;
    }
    
    // 累加计数
    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }
    
    // 从后向前构建输出数组
    for (int i = arr.length - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }
    
    // 复制到原数组
    for (int i = 0; i < arr.length; i++) {
        arr[i] = output[i];
    }
}
```

##### 对象排序

通过提取对象的整数键进行排序：

```java
▼Java复制代码class Student {
    String name;
    int score;
    
    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }
    
    @Override
    public String toString() {
        return name + ": " + score;
    }
}

public static void countingSortStudents(Student[] students) {
    // 找出最高分和最低分
    int max = students[0].score, min = students[0].score;
    for (int i = 1; i < students.length; i++) {
        if (students[i].score > max) {
            max = students[i].score;
        }
        if (students[i].score < min) {
            min = students[i].score;
        }
    }
    
    // 计算范围
    int range = max - min + 1;
    
    // 创建计数数组
    int[] count = new int[range];
    for (Student student : students) {
        count[student.score - min]++;
    }
    
    // 累加计数
    for (int i = 1; i < range; i++) {
        count[i] += count[i - 1];
    }
    
    // 创建输出数组
    Student[] output = new Student[students.length];
    
    // 从后向前遍历，保证稳定性
    for (int i = students.length - 1; i >= 0; i--) {
        output[count[students[i].score - min] - 1] = students[i];
        count[students[i].score - min]--;
    }
    
    // 复制回原数组
    for (int i = 0; i < students.length; i++) {
        students[i] = output[i];
    }
}
```

#### 测验

这里准备了一些测试题，方便大家判断自己的掌握情况：

1. 计数排序的时间复杂度是多少？它与归并排序相比有什么优势？
2. 计数排序适用于哪些数据类型？为什么不适合排序浮点数？
3. 如何修改计数排序使其能够处理负数？

> 测验答案
>
> 1. 计数排序的时间复杂度是 O(n+k)，其中 k 是数据范围。当 k 较小时，它比归并排序 O(nlogn) 更高效。
> 2. 计数排序主要适用于整数数据类型。浮点数理论上有无限多个取值，不方便直接用索引表示，精度问题也会导致统计困难。
> 3. 通过找出最小值 min，并使用 arr[i] - min 作为索引。

### 八、希尔排序

#### 希尔排序

希尔排序是插入排序的改进版本，通过比较相距一定间隔的元素来工作，逐步减小间隔直到只比较相邻元素。

时间复杂度:最佳 O(n log n) | 平均 O(n log² n) | 最差 O(n²)    空间复杂度:O(1)

稳定性:不稳定

>##### 应用场景/前提条件
>
>- 插入排序的改进版
>- 适用于中等规模数据

#### 算法讲解

##### 介绍

希尔排序（Shell Sort）是插入排序的一种改进版本，它是第一个突破O(n²)的排序算法，核心思想是利用**步长序列**对数据进行分组，在每个分组内使用插入排序，逐步减小步长直到为1，完成最终排序。

希尔排序时元素会大跨度移动，解决了插入排序在处理大规模乱序数组效率低下的问题，让元素更快移动到正确位置。虽然说后来出现了更高效的排序算法，但是希尔排序凭借其简单性和在中等规模数据上的良好表现，仍然是实际应用中的重要排序算法。

#### 算法步骤

1. 选择一个步长序列，建议初始步长 n/2，每次减半直到步长为1
2. 对每个步长，对数组进行分组，对应位置相隔为步长的元素视为一组
3. 对每一组使用插入排序进行排序
4. 减小步长，重复步骤2和3，直到步长减少到1
5. 当步长为1时，相当于对整个数组做一次插入排序，此时数组已基本有序，所需的比较和移动次数大大减少

为了帮助大家更好的理解，我们以初始数组 `[8, 9, 1, 7, 2, 6, 3, 5, 4]` 为例，查看每一步的详细流程：

1）第一轮排序

- 选择间隔 (Gap): 4 (数组长度9除以2取整)
- 分组: 按照间隔4将数组分为4个子序列。
  - 第1组 (下标0, 4, 8): `[8, 2, 4]`
  - 第2组 (下标1, 5): `[9, 6]`
  - 第3组 (下标2, 6): `[1, 3]`
  - 第4组 (下标3, 7): `[7, 5]`
- 对每组进行插入排序:
  - `[8, 2, 4]` 排序后变为 `[2, 4, 8]`
  - `[9, 6]` 排序后变为 `[6, 9]`
  - `[1, 3]` 排序后变为 `[1, 3]`
  - `[7, 5]` 排序后变为 `[5, 7]`
- 本轮结果: 将排序后的元素放回原位置，数组变为 `[2, 6, 1, 5, 4, 9, 3, 7, 8]`。

2）第二轮排序

- 缩小间隔 (Gap): 2 (上一间隔4除以2)

- 分组: 此时基于新数组

   

  ```
  [2, 6, 1, 5, 4, 9, 3, 7, 8]
  ```

  ，按照间隔2分为2个子序列。

  - 第1组 (偶数下标): `[2, 1, 4, 3, 8]`
  - 第2组 (奇数下标): `[6, 5, 9, 7]`

- 对每组进行插入排序:

  - `[2, 1, 4, 3, 8]` 排序后变为 `[1, 2, 3, 4, 8]`
  - `[6, 5, 9, 7]` 排序后变为 `[5, 6, 7, 9]`

- 本轮结果: 将元素放回原位置，数组变为 `[1, 5, 2, 6, 3, 7, 4, 9, 8]`。此时数组已经比之前更加有序。

3）第三轮排序（最终轮）

- 缩小间隔 (Gap): 1。
- 操作: 当间隔为1时，希尔排序就等同于对整个数组进行一次普通插入排序。
- 排序过程: 对 `[1, 5, 2, 6, 3, 7, 4, 9, 8]` 进行插入排序。由于数组已基本有序，这次排序的效率非常高。
- 最终排序结果: 数组变为完全有序的 `[1, 2, 3, 4, 5, 6, 7, 8, 9]`。

![img](https://bu.dusays.com/2025/09/21/68cffb37543fb.webp)

#### 核心特性

- 递减步长序列：初始较大步长让元素大幅度移动，后续减小步长微调元素位置
- 分组插入排序：对每个步长形成的分组独立应用插入排序
- 时间复杂度：取决于步长序列，一般在O(n1.3)到O(n2)之间
- 不稳定性：相等元素的相对位置在排序后可能会改变
- 适应性：对于中等大小的数组表现良好

#### 代码实现

```java
public class ShellSort {
    public static void shellSort(int[] arr) {
        int n = arr.length;
        
        // 初始步长为n/2，每次减半
        for (int gap = n/2; gap > 0; gap /= 2) {
            // 对每个步长进行插入排序
            for (int i = gap; i < n; i++) {
                // 保存当前元素
                int temp = arr[i];
                int j;
                
                // 对同一组的元素进行插入排序
                for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                    arr[j] = arr[j - gap];
                }
                
                // 将temp放到正确位置
                arr[j] = temp;
            }
        }
    }
    
    // 打印数组
    public static void printArray(int[] arr) {
        for (int i : arr) {
            System.out.print(i + " ");
        }
        System.out.println();
    }
    
    // 测试
    public static void main(String[] args) {
        int[] arr = {12, 34, 54, 2, 3, 1, 23, 45, 19, 92};
        System.out.println("排序前的数组：");
        printArray(arr);
        
        shellSort(arr);
        
        System.out.println("排序后的数组：");
        printArray(arr);
    }
}

```

希尔排序的核心是通过步长（gap）将数组分成多个子序列，对每个子序列进行插入排序。步长初始较大，逐渐减小，最终当步长为1时，整个数组已经基本有序，最后一轮插入排序效率很高。

```c
#include <stdio.h>

void shellSort(int arr[], int n) {
    // 初始步长为n/2，每次减半
    for (int gap = n/2; gap > 0; gap /= 2) {
        // 对每个步长进行插入排序
        for (int i = gap; i < n; i++) {
            // 保存当前元素
            int temp = arr[i];
            int j;
            
            // 对同一组的元素进行插入排序
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                arr[j] = arr[j - gap];
            }
            
            // 将temp放到正确位置
            arr[j] = temp;
        }
    }
}

// 打印数组
void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("
");
}

int main() {
    int arr[] = {12, 34, 54, 2, 3, 1, 23, 45, 19, 92};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    printf("排序前：");
    printArray(arr, n);
    
    shellSort(arr, n);
    
    printf("排序后：");
    printArray(arr, n);
    
    return 0;
}

```

#### 优化策略

##### 使用优化的步长序列

Knuth提出的步长序列可以提高希尔排序的性能：

```java
▼Java复制代码public static void knuthShellSort(int[] arr) {
    int n = arr.length;
    
    // 计算初始步长：Knuth序列 h = 3*h + 1
    int h = 1;
    while (h < n/3) {
        h = 3*h + 1;
    }
    
    // 使用Knuth序列进行希尔排序
    while (h >= 1) {
        // 对每个步长进行插入排序
        for (int i = h; i < n; i++) {
            int temp = arr[i];
            int j;
            
            for (j = i; j >= h && arr[j - h] > temp; j -= h) {
                arr[j] = arr[j - h];
            }
            
            arr[j] = temp;
        }
        
        // 更新步长
        h = h/3;
    }
}
```

##### Hibbard序列

Hibbard提出的步长序列也是一种常用优化：

```java
▼Java复制代码public static void hibbardShellSort(int[] arr) {
    int n = arr.length;
    
    // 计算初始步长：Hibbard序列 2^k - 1
    int k = 1;
    while ((1 << k) - 1 < n) {
        k++;
    }
    k--;
    
    // 使用Hibbard序列进行希尔排序
    while (k >= 0) {
        int gap = (1 << k) - 1;
        
        // 对每个步长进行插入排序
        // ... 与基本实现相同 ...
        
        k--;
    }
}
```

#### 优缺点

##### 优点

- 比插入排序更高效，尤其是对于大规模乱序数组
- 代码简单，容易实现
- 在中等大小的数组中性能良好
- 对于几乎已排序的数据效率很高
- 不需要额外的空间（原地排序）

##### 缺点

- 不是稳定的排序算法
- 步长序列的选择对性能影响很大
- 时间复杂度分析复杂，依赖于所选的步长序列
- 对于非常大的数据集，其他高级排序算法（如快速排序、堆排序）可能更高效
- 对于非常小的数据集，简单的插入排序可能更高效

#### 应用场景

- 中等规模的数据排序
- 作为更复杂排序算法的预处理步骤
- 数组基本有序但有少数元素错位较远的情况
- 嵌入式系统或资源受限环境中的排序
- 实时系统中需要可预测性能的场景

#### 扩展

##### 结合其他排序算法

可以将希尔排序与其他排序算法结合使用，例如在最后一轮（gap=1）时使用插入排序的优化版本：

```java
▼Java复制代码public static void hybridShellSort(int[] arr) {
    int n = arr.length;
    
    // 使用希尔排序进行预处理
    for (int gap = n/2; gap > 1; gap /= 2) {
        // ... 标准希尔排序代码 ...
    }
    
    // 最后一轮使用优化的插入排序
    binaryInsertionSort(arr);
}

public static void binaryInsertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int key = arr[i];
        int left = 0;
        int right = i - 1;
        
        // 使用二分查找找到插入位置
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] > key) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        // 将元素后移
        for (int j = i - 1; j >= left; j--) {
            arr[j + 1] = arr[j];
        }
        
        // 插入元素
        arr[left] = key;
    }
}
```

#### 测验

这里准备了一些测试题，方便大家判断自己的掌握情况：

1. 希尔排序的时间复杂度取决于什么？
2. 希尔排序相比于插入排序的主要优势是什么？
3. 为什么说希尔排序是第一个突破O(n²)的排序算法？

> 测验答案
>
> 1. 步长序列的选择，不同的步长序列会导致不同的时间复杂度。
> 2. 能够让元素进行大跨度移动，更快地接近最终位置，特别适合大规模乱序数组。
> 3. 希尔排序在某些步长序列下可以达到O(n^1.3)等 亚二次时间复杂度。

### 九、桶排序

#### 桶排序

桶排序是一种分配式排序算法，将元素分到有限数量的桶里，每个桶再单独排序（比如用插入排序），最后依次把各个桶中的元素取出来即完成排序。

时间复杂度:最佳 O(n) | 平均 O(n + n²/k + k) | 最差 O(n²)   空间复杂度:O(n + k)

稳定性:稳定

>##### 应用场景/前提条件
>
>- 适合均匀分布的数据
>- 需要额外空间
>- 可以与其他排序算法结合

#### 算法讲解

##### 介绍

桶排序（Bucket Sort）是一种分布式排序算法，核心思想是将数据分散到有限数量的桶中，然后对每个桶中的数据进行排序，最后将各个桶中的数据有序地合并起来。桶排序是计数排序的扩展版本，特别适合均匀分布的数据集。

桶排序的效率取决于数据分布的均匀性。在最佳情况下，桶排序的时间复杂度可以达到 O(n)，在特定场景下非常高效。桶排序结合了哈希表的思想，通过映射函数将元素分配到不同的桶中实现排序。

#### 算法步骤

1. 确定桶的数量和范围，创建对应数量的桶（通常是数组或链表）
2. 根据映射函数将每个元素分配到对应的桶中
3. 对每个桶内的元素分别进行排序（可以使用任何排序算法）
4. 按照桶的顺序将各个桶中的元素依次取出，组成有序序列![img](https://algo.codefather.cn/algorithms/sorting/需要桶排序流程图)![img](https://bu.dusays.com/2025/09/21/68cffc8498b9d.webp)

#### 核心特性

- 分布式排序：将元素分散到多个桶中进行局部排序
- 映射函数：需要一个合理的映射函数决定元素与桶的对应关系
- 时间复杂度：平均情况为 O(n+k)，其中 k 是桶的数量，最坏情况为 O(n²)
- 空间复杂度：O(n+k)，需要额外空间存储桶和临时数据
- 稳定性：取决于桶内排序使用的算法，如果使用稳定的排序算法那么桶排序也是稳定的

#### 代码实现

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class BucketSort {
    public static void bucketSort(double[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        // 确定桶的数量
        int bucketCount = arr.length;
        
        // 创建桶
        List<List<Double>> buckets = new ArrayList<>(bucketCount);
        for (int i = 0; i < bucketCount; i++) {
            buckets.add(new ArrayList<>());
        }
        
        // 找出数组中的最大值和最小值
        double max = arr[0], min = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
            if (arr[i] < min) {
                min = arr[i];
            }
        }
        
        // 计算每个桶的范围大小
        double range = (max - min) / bucketCount;
        
        // 将元素分配到对应的桶中
        for (double item : arr) {
            // 计算元素应该放入哪个桶
            int bucketIndex = (int)((item - min) / range);
            
            // 处理最大值的边界情况
            if (bucketIndex == bucketCount) {
                bucketIndex--;
            }
            
            buckets.get(bucketIndex).add(item);
        }
        
        // 对每个桶中的元素进行排序
        for (List<Double> bucket : buckets) {
            Collections.sort(bucket);
        }
        
        // 将桶中排序好的元素放回原数组
        int index = 0;
        for (List<Double> bucket : buckets) {
            for (double item : bucket) {
                arr[index++] = item;
            }
        }
    }
    
    // 打印数组
    public static void printArray(double[] arr) {
        for (double item : arr) {
            System.out.print(item + " ");
        }
        System.out.println();
    }
    
    // 测试
    public static void main(String[] args) {
        double[] arr = {0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51};
        System.out.println("排序前的数组：");
        printArray(arr);
        
        bucketSort(arr);
        
        System.out.println("排序后的数组：");
        printArray(arr);
    }
}

```

#### 优化策略

##### 动态调整桶的数量

根据上面的介绍我们知道，桶的数量会影响算法性能，所以可以根据数据分布动态调整：

```java
▼Java复制代码public static void bucketSort(double[] arr) {
    // 估计数据的分布情况
    double variance = calculateVariance(arr);
    
    // 根据方差动态确定桶的数量
    int bucketCount;
    if (variance < 0.1) {
        // 数据分布均匀，使用更多的桶
        bucketCount = arr.length;
    } else if (variance < 0.5) {
        // 数据分布一般，使用中等数量的桶
        bucketCount = arr.length / 2;
    } else {
        // 数据分布不均匀，使用较少的桶
        bucketCount = arr.length / 4;
    }
    
    // 后续桶排序逻辑
    // ...
}

private static double calculateVariance(double[] arr) {
    // 计算数组的方差，用于评估数据分布
    double sum = 0, squareSum = 0;
    for (double num : arr) {
        sum += num;
        squareSum += num * num;
    }
    double mean = sum / arr.length;
    return (squareSum / arr.length) - (mean * mean);
}
```

##### 优化桶内排序

针对不同大小和数据特性的桶，选择不同的排序算法：

```java
▼Java复制代码private static void sortBucket(List<Double> bucket) {
    if (bucket.size() <= 1) {
        return;
    }
    
    if (bucket.size() <= 10) {
        // 对于小规模数据，使用插入排序
        insertionSort(bucket);
    } else {
        // 对于大规模数据，使用快速排序或其他高效算法
        Collections.sort(bucket);
    }
}

private static void insertionSort(List<Double> list) {
    for (int i = 1; i < list.size(); i++) {
        double key = list.get(i);
        int j = i - 1;
        
        while (j >= 0 && list.get(j) > key) {
            list.set(j + 1, list.get(j));
            j--;
        }
        
        list.set(j + 1, key);
    }
}
```

#### 优缺点

##### 优点

- 当数据分布均匀时，时间复杂度接近 O(n)，非常高效
- 适合外部排序，可以有效处理大规模数据
- 可以与其他排序算法结合使用
- 适合对浮点数进行排序
- 适合并行化实现

##### 缺点

- 对数据分布敏感，最坏情况下可能退化到 O(n²)
- 需要额外的空间存储桶
- 桶的数量和映射函数选择对性能影响很大
- 对于非均匀分布的数据，可能导致某些桶过大，效率下降
- 需要知道数据的大致分布情况才能设计最优的桶数量

#### 应用场景

接下来看下桶排序的应用场景：

1）数据分布相对均匀的场景，如随机生成的[0,1)区间内均匀分布的浮点数

2）外部排序，处理无法一次性装入内存的大规模数据

4）并行计算环境中，可以将数据分散到不同节点处理

5）与其他算法结合，比如作为基数排序或分布式系统中的预处理步骤

#### 扩展

##### 应用于外部排序

当数据量过大无法一次性加载到内存时，可以使用桶排序思想：

```java
▼Java复制代码public static void externalBucketSort(String inputFile, String outputFile, int bucketCount) {
    // 第一阶段：扫描文件，确定数据范围
    double min = Double.MAX_VALUE;
    double max = Double.MIN_VALUE;
    
    // 读取文件，找出最大值和最小值
    
    // 第二阶段：创建桶文件
    String[] bucketFiles = new String[bucketCount];
    for (int i = 0; i < bucketCount; i++) {
        bucketFiles[i] = "bucket_" + i + ".tmp";
    }
    
    // 第三阶段：将输入文件的数据分配到各个桶文件中
    double range = (max - min) / bucketCount;
    
    // 第四阶段：对每个桶文件进行排序
    for (int i = 0; i < bucketCount; i++) {
        // 读取桶文件到内存，排序后写回
    }
    
    // 第五阶段：合并所有排序好的桶文件到输出文件
}
```

##### 多维桶排序

扩展到多维数据的排序：

```java
▼Java复制代码class Point {
    double x, y;
    
    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }
    
    @Override
    public String toString() {
        return "(" + x + ", " + y + ")";
    }
}

public static void bucketSortPoints(Point[] points) {
    // 确定x和y维度的范围
    double minX = Double.MAX_VALUE, maxX = Double.MIN_VALUE;
    double minY = Double.MAX_VALUE, maxY = Double.MIN_VALUE;
    
    for (Point p : points) {
        minX = Math.min(minX, p.x);
        maxX = Math.max(maxX, p.x);
        minY = Math.min(minY, p.y);
        maxY = Math.max(maxY, p.y);
    }
    
    // 确定网格桶数量（根据数据规模调整）
    int xBuckets = (int)Math.sqrt(points.length);
    int yBuckets = (int)Math.sqrt(points.length);
    
    // 创建二维桶数组
    List<Point>[][] buckets = new ArrayList[xBuckets][yBuckets];
    for (int i = 0; i < xBuckets; i++) {
        for (int j = 0; j < yBuckets; j++) {
            buckets[i][j] = new ArrayList<>();
        }
    }
    
    // 计算每个维度的范围大小
    double xRange = (maxX - minX) / xBuckets;
    double yRange = (maxY - minY) / yBuckets;
    
    // 将点分配到对应的桶中
    for (Point p : points) {
        int xIndex = (int)((p.x - minX) / xRange);
        int yIndex = (int)((p.y - minY) / yRange);
        
        // 处理边界情况
        if (xIndex == xBuckets) xIndex--;
        if (yIndex == yBuckets) yIndex--;
        
        buckets[xIndex][yIndex].add(p);
    }
    
    // 对每个桶中的点进行排序（例如，先按x再按y）
    for (int i = 0; i < xBuckets; i++) {
        for (int j = 0; j < yBuckets; j++) {
            Collections.sort(buckets[i][j], (p1, p2) -> {
                if (p1.x != p2.x) {
                    return Double.compare(p1.x, p2.x);
                }
                return Double.compare(p1.y, p2.y);
            });
        }
    }
    
    // 收集结果
    int index = 0;
    for (int i = 0; i < xBuckets; i++) {
        for (int j = 0; j < yBuckets; j++) {
            for (Point p : buckets[i][j]) {
                points[index++] = p;
            }
        }
    }
}
```

#### 测验

这里准备了一些测试题，方便大家判断自己的掌握情况：

1. 桶排序的平均时间复杂度是多少？在什么情况下会达到这个复杂度？
2. 桶排序的最坏时间复杂度是多少？什么情况下会出现？
3. 如何选择合适的桶数量和映射函数？

> 测验答案
>
> 1. 平均时间复杂度是 O(n+k)，其中 k 是桶的数量。数据均匀分布、每个桶内元素数量接近相同的时候。
> 2. 最坏时间复杂度是 O(n²)，当所有元素都被映射到同一个桶中时可能达到。
> 3. 桶的数量通常与输入数据量相当，映射函数要尽可能保证元素均匀分布到各个桶中。

### 十、计数排序

#### 计数排序

基数排序是一种非比较型的排序算法，通过逐位比较元素的每一位（从最低位到最高位）来实现排序。

时间复杂度:最佳 O(n * k) | 平均 O(n * k) | 最差 O(n * k)    空间复杂度:O(n + k)

稳定性:稳定

>##### 应用场景/前提条件
>
>- 适用于整数排序
>- 非比较型排序
>- k为最大整数位数

#### 算法讲解

##### 介绍

基数排序（Radix Sort）是一种非比较型的排序算法，核心思想是按照数位来排序，从最低有效位（Least Significant Digit, LSD）或最高有效位（Most Significant Digit, MSD）开始，依次对每个位置的数字进行排序。基数排序特别适合用于整数或定长字符串的排序，时间复杂度是 O(n×k)，其中 n 是待排序数组的长度，k 是数据的最大位数。

基数排序不会直接比较元素之间的大小，通过分配和收集过程实现排序，在一些特定场景下性能优于比较排序算法。

#### 算法步骤

1. 找出待排序数组中的最大值，确定最大位数
2. 从最低位开始，对每一位上的数字进行计数排序（或桶排序）
3. 按照当前位的数字大小将元素重新排列
4. 对下一个更高位重复步骤2和3，直到处理完所有位

![img](https://bu.dusays.com/2025/09/21/68cffd76a9ed1.webp)

![img](https://bu.dusays.com/2025/09/21/68cffd76afe6f.webp)

![img](https://algo.codefather.cn/algorithms/sorting/需要基数排序流程图)

#### 核心特性

- 非比较排序：不通过比较元素大小进行排序
- 稳定排序：相等元素的相对位置在排序后不会改变
- 时间复杂度：O(n×k)，其中 k 是数据的最大位数
- 空间复杂度：O(n+r)，其中 r 是基数（比如十进制数的基数为10）
- 适用范围：整数或固定长度的字
- 符串

#### 代码实现

```java
public class RadixSort {
    public static void radixSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        // 找出最大值，确定最大位数
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        
        // 对每一位进行计数排序
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countingSortByDigit(arr, exp);
        }
    }
    
    private static void countingSortByDigit(int[] arr, int exp) {
        int n = arr.length;
        int[] output = new int[n]; // 输出数组
        int[] count = new int[10]; // 计数数组，默认为10，因为一位数字的范围是0~9
        
        // 统计当前位上每个数字出现的次数
        for (int i = 0; i < n; i++) {
            int digit = (arr[i] / exp) % 10;
            count[digit]++;
        }
        
        // 计算累加数组，确定每个数字在输出数组中的位置
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }
        
        // 构建输出数组，从后向前遍历以保持稳定性
        for (int i = n - 1; i >= 0; i--) {
            int digit = (arr[i] / exp) % 10;
            output[count[digit] - 1] = arr[i];
            count[digit]--;
        }
        
        // 将排序好的数组复制回原数组
        for (int i = 0; i < n; i++) {
            arr[i] = output[i];
        }
    }
    
    // 打印数组
    public static void printArray(int[] arr) {
        for (int i : arr) {
            System.out.print(i + " ");
        }
        System.out.println();
    }
    
    // 测试
    public static void main(String[] args) {
        int[] arr = {170, 45, 75, 90, 802, 24, 2, 66};
        System.out.println("排序前的数组：");
        printArray(arr);
        
        radixSort(arr);
        
        System.out.println("排序后的数组：");
        printArray(arr);
    }
}

```

关键步骤如下：

```java
// 对每一位进行计数排序
for (int exp = 1; max / exp > 0; exp *= 10) {
    countingSortByDigit(arr, exp);
}

```

这里实现了基数排序的核心思想，从最低位开始依次对每个位置的数字进行排序。使用计数排序作为每一轮的排序算法，保证排序稳定性。

```c
#include <stdio.h>
#include <stdlib.h>

// 获取数组中的最大值
int getMax(int arr[], int n) {
    int max = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}

// 对数组按照特定数位进行计数排序
void countingSortByDigit(int arr[], int n, int exp) {
    int* output = (int*)malloc(n * sizeof(int));
    int count[10] = {0}; // 计数数组，默认为10
    
    // 统计当前位上每个数字出现的次数
    for (int i = 0; i < n; i++) {
        count[(arr[i] / exp) % 10]++;
    }
    
    // 计算累加数组，确定每个数字在输出数组中的位置
    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }
    
    // 构建输出数组，从后向前遍历以保持稳定性
    for (int i = n - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }
    
    // 将排序好的数组复制回原数组
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }
    
    free(output);
}

// 基数排序
void radixSort(int arr[], int n) {
    if (n <= 1) {
        return;
    }
    
    // 找出最大值，确定最大位数
    int max = getMax(arr, n);
    
    // 对每一位进行计数排序
    for (int exp = 1; max / exp > 0; exp *= 10) {
        countingSortByDigit(arr, n, exp);
    }
}

// 打印数组
void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("
");
}

int main() {
    int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    printf("排序前：");
    printArray(arr, n);
    
    radixSort(arr, n);
    
    printf("排序后：");
    printArray(arr, n);
    
    return 0;
}

```

#### 优化策略

##### 处理负数

标准的基数排序不能直接处理负数，可以通过以下方式优化：

```java
▼Java复制代码public static void radixSortWithNegatives(int[] arr) {
    if (arr == null || arr.length <= 1) {
        return;
    }
    
    // 将数组分为负数和非负数两部分
    List<Integer> negatives = new ArrayList<>();
    List<Integer> nonNegatives = new ArrayList<>();
    
    for (int num : arr) {
        if (num < 0) {
            negatives.add(-num); // 负数取绝对值
        } else {
            nonNegatives.add(num);
        }
    }
    
    // 将负数数组转换为整数数组
    int[] negArr = new int[negatives.size()];
    for (int i = 0; i < negatives.size(); i++) {
        negArr[i] = negatives.get(i);
    }
    
    // 将非负数数组转换为整数数组
    int[] nonNegArr = new int[nonNegatives.size()];
    for (int i = 0; i < nonNegatives.size(); i++) {
        nonNegArr[i] = nonNegatives.get(i);
    }
    
    // 对两部分分别进行基数排序
    radixSort(negArr);
    radixSort(nonNegArr);
    
    // 将排序后的负数部分逆序并取反，与非负数部分合并
    int index = 0;
    for (int i = negArr.length - 1; i >= 0; i--) {
        arr[index++] = -negArr[i];
    }
    
    for (int i = 0; i < nonNegArr.length; i++) {
        arr[index++] = nonNegArr[i];
    }
}
```

##### 使用不同基数

通过改变基数（radix）来优化算法性能：

```java
▼Java复制代码public static void radixSortWithCustomBase(int[] arr, int base) {
    if (arr == null || arr.length <= 1) {
        return;
    }
    
    // 找出最大值，确定最大位数
    int max = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    
    // 对每一位进行计数排序
    for (int exp = 1; max / exp > 0; exp *= base) {
        countingSortByDigitWithBase(arr, exp, base);
    }
}

private static void countingSortByDigitWithBase(int[] arr, int exp, int base) {
    int n = arr.length;
    int[] output = new int[n];
    int[] count = new int[base]; // 计数数组大小为基数
    
    // 统计当前位上每个数字出现的次数
    for (int i = 0; i < n; i++) {
        int digit = (arr[i] / exp) % base;
        count[digit]++;
    }
    
    // 计算累加数组
    for (int i = 1; i < base; i++) {
        count[i] += count[i - 1];
    }
    
    // 构建输出数组
    for (int i = n - 1; i >= 0; i--) {
        int digit = (arr[i] / exp) % base;
        output[count[digit] - 1] = arr[i];
        count[digit]--;
    }
    
    // 复制回原数组
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }
}
```

#### 优缺点

##### 优点

- 在固定位数的情况下，时间复杂度可达到 O(n)，比 比较排序 更快
- 稳定排序算法，能保持相等元素的相对顺序
- 适合处理大量数据和长整数
- 不受输入数据分布影响，排序性能稳定
- 适合处理位数相同的字符串

##### 缺点

- 只适用于整数和定长字符串等可以分解为独立"位"的数据
- 需要额外的空间进行计数和输出
- 如果数据最大值很大，但数据量很小，会导致很多不必要的空桶操作
- 对负数需要特殊处理
- 不适合对浮点数直接进行排序（需要特殊转换）

#### 应用场景

1）固定长度的整数排序，如电话号码、邮政编码等

2）字符串排序，比如单词字典、文件名

3）大数据量但数值范围有限的数据集排序

4）配合其他排序算法构建混合排序策略

#### 扩展

##### 字符串排序

```java
▼Java复制代码public static void radixSortStrings(String[] arr, int maxLength) {
    if (arr == null || arr.length <= 1) {
        return;
    }
    
    // 从最低位（最右侧）开始，对每一位进行计数排序
    for (int pos = maxLength - 1; pos >= 0; pos--) {
        countingSortByCharPosition(arr, pos);
    }
}

private static void countingSortByCharPosition(String[] arr, int pos) {
    int n = arr.length;
    String[] output = new String[n];
    
    // 字符的ASCII范围，这里简化为128
    int[] count = new int[128];
    
    // 对于短于pos的字符串，认为该位是空字符（ASCII为0）
    for (int i = 0; i < n; i++) {
        int charIndex = (pos < arr[i].length()) ? arr[i].charAt(pos) : 0;
        count[charIndex]++;
    }
    
    // 计算累加数组
    for (int i = 1; i < 128; i++) {
        count[i] += count[i - 1];
    }
    
    // 构建输出数组，从后向前遍历以保持稳定性
    for (int i = n - 1; i >= 0; i--) {
        int charIndex = (pos < arr[i].length()) ? arr[i].charAt(pos) : 0;
        output[count[charIndex] - 1] = arr[i];
        count[charIndex]--;
    }
    
    // 复制回原数组
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }
}
```

##### MSD基数排序

最高位优先（Most Significant Digit, MSD）的基数排序适合字典排序：

```java
▼Java复制代码public static void msdRadixSort(int[] arr) {
    if (arr == null || arr.length <= 1) {
        return;
    }
    
    // 找出最大值，确定最大位数
    int max = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    
    // 计算最大位数
    int maxDigits = 0;
    while (max > 0) {
        maxDigits++;
        max /= 10;
    }
    
    // 从最高位开始排序
    int[] temp = new int[arr.length];
    msdRadixSortRecursive(arr, temp, 0, arr.length - 1, maxDigits);
}

private static void msdRadixSortRecursive(int[] arr, int[] temp, int low, int high, int digit) {
    if (low >= high || digit <= 0) {
        return;
    }
    
    // 计算当前位的除数
    int divisor = (int)Math.pow(10, digit - 1);
    
    // 统计每个数字出现的次数
    int[] count = new int[10];
    for (int i = low; i <= high; i++) {
        int d = (arr[i] / divisor) % 10;
        count[d]++;
    }
    
    // 计算起始位置
    int[] startPos = new int[10];
    startPos[0] = low;
    for (int i = 1; i < 10; i++) {
        startPos[i] = startPos[i - 1] + count[i - 1];
    }
    
    // 排序当前位
    for (int i = low; i <= high; i++) {
        int d = (arr[i] / divisor) % 10;
        temp[startPos[d]++] = arr[i];
    }
    
    // 复制回原数组
    for (int i = low; i <= high; i++) {
        arr[i] = temp[i];
    }
    
    // 对每个数字分组进行递归排序
    int start = low;
    for (int i = 0; i < 10; i++) {
        int end = start + count[i] - 1;
        if (end > start) {
            msdRadixSortRecursive(arr, temp, start, end, digit - 1);
        }
        start = end + 1;
    }
}
```

#### 测验

这里准备了一些测试题，方便大家判断自己的掌握情况：

1. 基数排序的时间复杂度是多少？它跟归并排序相比有什么优势？
2. LSD（最低位优先）和MSD（最高位优先）基数排序有什么区别？
3. 基数排序在处理不同类型数据时有哪些限制？

> 测验答案
>
> 1. 基数排序的时间复杂度是 O(n×k)，其中 k 是数据的最大位数。当 k 较小时，基数排序可以接近 O(n)，比归并排序的 O(nlogn) 更高效。
> 2. LSD从最低位开始排序，适合按数值大小排序；MSD从最高位开始排序，适合字典序排序。LSD需要对所有数据统一排序每一位，MSD可以递归处理不同的子集。
> 3. 基数排序主要适合处理可以分解为独立"位"的数据，比如整数和定长字符串，不适合直接处理浮点数、变长字符串等类型。

## 字符串匹配

### 一、Rabin-Karp算法

#### Rabin-Karp算法

Rabin-Karp是一种基于哈希的字符串匹配算法，通过计算哈希值快速过滤不匹配的位置，是一种高效的字符串搜索方法，尤其适合多模式匹配场景。

#### 算法讲解

#####  介绍

Rabin-Karp算法是一种**基于哈希函数的字符串匹配算法**，由 Michael O. Rabin 和 Richard M. Karp 于1987年提出，核心思想是用**哈希函数**将模式串和文本串中的子串转换为数值进行比较，避免大量不必要的字符比较。这个算法特别适合**多模式串匹配场景**，时间复杂度平均为O(n+m)，n是文本串长度，m是模式串长度。

Rabin-Karp算法的关键在于使用**滚动哈希函数**（Rolling Hash），它可以在常数时间内计算出滑动窗口的新哈希值，保证算法在大多数情况下的高效性。

#### 算法步骤

1. 计算模式串的哈希值
2. 计算文本串中长度为m的第一个子串的哈希值（m为模式串长度）
3. 在文本串上滑动窗口，对于每个位置：
   - 使用滚动哈希技术高效计算当前窗口的哈希值
   - 如果哈希值与模式串相等，则进行字符逐一比较以避免哈希冲突
   - 如果完全匹配，则找到一个匹配位置
4. 重复步骤3，直到处理完整个文本串

#### 核心特性

- **基于哈希比较**：通过哈希值比较代替直接字符比较
- **滚动哈希**：O(1)时间复杂度计算下一窗口的哈希值
- **时间复杂度**：平均情况O(n+m)，最坏情况O(n*m)
- **空间复杂度**：O(1)，只需常数额外空间
- **适用范围**：单模式和多模式串匹配场景，特别是多模式匹配

#### 代码实现

```java
public class RabinKarp {
    private final static int PRIME = 101; // 哈希计算使用的质数
    
    public static int search(String text, String pattern) {
        int m = pattern.length();
        int n = text.length();
        
        if (m > n) return -1;
        if (m == 0) return 0;
        
        // 计算哈希乘数，等于d^(m-1) % PRIME，用于滚动哈希计算
        int h = 1;
        for (int i = 0; i < m - 1; i++) {
            h = (h * 256) % PRIME;
        }
        
        // 计算模式串和第一个窗口的哈希值
        int patternHash = 0;
        int textHash = 0;
        for (int i = 0; i < m; i++) {
            patternHash = (256 * patternHash + pattern.charAt(i)) % PRIME;
            textHash = (256 * textHash + text.charAt(i)) % PRIME;
        }
        
        // 滑动窗口，比较哈希值
        for (int i = 0; i <= n - m; i++) {
            // 哈希值相等时，检查是否真正匹配
            if (patternHash == textHash) {
                boolean match = true;
                for (int j = 0; j < m; j++) {
                    if (text.charAt(i + j) != pattern.charAt(j)) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    return i; // 找到匹配
                }
            }
            
            // 计算下一个窗口的哈希值
            if (i < n - m) {
                textHash = (256 * (textHash - text.charAt(i) * h) + text.charAt(i + m)) % PRIME;
                // 处理负数哈希值
                if (textHash < 0) {
                    textHash += PRIME;
                }
            }
        }
        
        return -1; // 未找到匹配
    }
    
    // 打印结果
    public static void main(String[] args) {
        String text = "ABABCABABDABACDABABCABAB";
        String pattern = "ABABCABAB";
        
        int position = search(text, pattern);
        if (position == -1) {
            System.out.println("未找到匹配");
        } else {
            System.out.println("模式串在位置 " + position + " 处匹配");
            System.out.println(text);
            // 打印指示匹配位置的指针
            for (int i = 0; i < position; i++) {
                System.out.print(" ");
            }
            System.out.println(pattern);
        }
    }
}

```

#### 优化策略

##### 使用更好的哈希函数

比如使用更复杂的哈希函数来减少冲突：

```java
▼Java复制代码public class ImprovedRabinKarp {
    private final static long PRIME1 = 1000000007; // 第一个哈希的质数
    private final static long PRIME2 = 1000000009; // 第二个哈希的质数
    
    // 使用双哈希来减少冲突
    public static int search(String text, String pattern) {
        int m = pattern.length();
        int n = text.length();
        
        if (m > n) return -1;
        if (m == 0) return 0;
        
        // 计算哈希乘数
        long h1 = 1;
        long h2 = 1;
        for (int i = 0; i < m - 1; i++) {
            h1 = (h1 * 256) % PRIME1;
            h2 = (h2 * 256) % PRIME2;
        }
        
        // 计算模式串和第一个窗口的哈希值
        long patternHash1 = 0;
        long patternHash2 = 0;
        long textHash1 = 0;
        long textHash2 = 0;
        
        for (int i = 0; i < m; i++) {
            patternHash1 = (256 * patternHash1 + pattern.charAt(i)) % PRIME1;
            patternHash2 = (256 * patternHash2 + pattern.charAt(i)) % PRIME2;
            textHash1 = (256 * textHash1 + text.charAt(i)) % PRIME1;
            textHash2 = (256 * textHash2 + text.charAt(i)) % PRIME2;
        }
        
        // 滑动窗口，比较哈希值
        for (int i = 0; i <= n - m; i++) {
            // 两个哈希都相等时，再进行字符比较
            if (patternHash1 == textHash1 && patternHash2 == textHash2) {
                boolean match = true;
                for (int j = 0; j < m; j++) {
                    if (text.charAt(i + j) != pattern.charAt(j)) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    return i; // 找到匹配
                }
            }
            
            // 计算下一个窗口的哈希值
            if (i < n - m) {
                textHash1 = (256 * (textHash1 - text.charAt(i) * h1) + text.charAt(i + m)) % PRIME1;
                textHash2 = (256 * (textHash2 - text.charAt(i) * h2) + text.charAt(i + m)) % PRIME2;
                
                // 处理负数哈希值
                if (textHash1 < 0) textHash1 += PRIME1;
                if (textHash2 < 0) textHash2 += PRIME2;
            }
        }
        
        return -1; // 未找到匹配
    }
}
```

#### 优缺点

##### 优点

- 平均情况下时间复杂度为O(n+m)，接近线性时间
- 在多模式匹配场景下效率高
- 可以通过预处理模式串提高效率
- 滚动哈希计算使得算法高效移动窗口
- 实现相对简单，原理容易理解

##### 缺点

- 哈希冲突可能导致额外的字符比较
- 最坏情况下的时间复杂度为O(n*m)
- 哈希函数的选择对算法性能影响很大
- 需要注意数值溢出问题
- 对于短模式串和文本串，预处理开销可能抵消算法优势

#### 应用场景

1）文档相似度检测和抄袭检测

2）网络安全中的特征码匹配

3）多模式字符串搜索引擎

4）编译器中的词法分析器

#### 扩展

##### Rabin-Karp指纹算法

Rabin-Karp算法的一个变种应用于文件相似度比较：

```java
▼Java复制代码public class RabinKarpFingerprint {
    private final static long PRIME = 1000000007;
    private final static int WINDOW_SIZE = 5; // 指纹窗口大小
    
    public static Set<Long> generateFingerprints(String text) {
        Set<Long> fingerprints = new HashSet<>();
        int n = text.length();
        
        if (n < WINDOW_SIZE) {
            fingerprints.add(calculateHash(text, n));
            return fingerprints;
        }
        
        // 计算第一个窗口的哈希值
        long textHash = calculateHash(text, WINDOW_SIZE);
        fingerprints.add(textHash);
        
        // 计算哈希乘数
        long h = 1;
        for (int i = 0; i < WINDOW_SIZE - 1; i++) {
            h = (h * 256) % PRIME;
        }
        
        // 滑动窗口，计算所有长度为WINDOW_SIZE的子串哈希值
        for (int i = 0; i <= n - WINDOW_SIZE - 1; i++) {
            textHash = (256 * (textHash - text.charAt(i) * h) + text.charAt(i + WINDOW_SIZE)) % PRIME;
            if (textHash < 0) {
                textHash += PRIME;
            }
            fingerprints.add(textHash);
        }
        
        return fingerprints;
    }
    
    public static double calculateSimilarity(String text1, String text2) {
        Set<Long> fingerprints1 = generateFingerprints(text1);
        Set<Long> fingerprints2 = generateFingerprints(text2);
        
        // 计算交集大小
        Set<Long> intersection = new HashSet<>(fingerprints1);
        intersection.retainAll(fingerprints2);
        
        // 计算并集大小
        Set<Long> union = new HashSet<>(fingerprints1);
        union.addAll(fingerprints2);
        
        // 杰卡德相似度系数
        return (double) intersection.size() / union.size();
    }
    
    private static long calculateHash(String str, int length) {
        long hash = 0;
        for (int i = 0; i < length; i++) {
            hash = (256 * hash + str.charAt(i)) % PRIME;
        }
        return hash;
    }
}
```

##### 子字符串哈希

一些编程竞赛里也使用Rabin-Karp思想进行高效的子字符串查询：

```java
▼Java复制代码public class SubstringHash {
    private static final long PRIME = 1000000007;
    private static final int BASE = 256;
    
    private long[] hash; // 前缀哈希值
    private long[] pow;  // BASE的幂
    private String s;    // 源字符串
    
    public SubstringHash(String s) {
        this.s = s;
        int n = s.length();
        hash = new long[n + 1];
        pow = new long[n + 1];
        
        // 预计算BASE的幂
        pow[0] = 1;
        for (int i = 1; i <= n; i++) {
            pow[i] = (pow[i - 1] * BASE) % PRIME;
        }
        
        // 计算所有前缀的哈希值
        hash[0] = 0;
        for (int i = 0; i < n; i++) {
            hash[i + 1] = (hash[i] * BASE + s.charAt(i)) % PRIME;
        }
    }
    
    // 计算子串s[l..r]的哈希值（0-indexed）
    public long substringHash(int l, int r) {
        // 获取s[0...r]的哈希值，减去s[0...l-1]的哈希值（需要进行适当调整）
        long result = (hash[r + 1] - (hash[l] * pow[r - l + 1]) % PRIME) % PRIME;
        if (result < 0) {
            result += PRIME;
        }
        return result;
    }
    
    // 检查两个子串是否相同
    public boolean areSubstringsEqual(int l1, int r1, int l2, int r2) {
        if (r1 - l1 != r2 - l2) {
            return false; // 长度不同
        }
        return substringHash(l1, r1) == substringHash(l2, r2);
    }
}
```

#### 测验

这里准备了一些测试题，方便大家判断自己的掌握情况：

1. Rabin-Karp算法的核心思想是什么？它与朴素字符串匹配算法的主要区别是什么？
2. 滚动哈希的计算过程是怎样的？为什么它能在O(1)时间内计算新的哈希值？
3. 哈希冲突会对Rabin-Karp算法造成什么影响？如何减少哈希冲突？
4. Rabin-Karp算法在多模式匹配上有什么优势？
5. 在实际应用中，如何选择合适的哈希函数和模数？

> 测验答案
>
> 1. 用哈希值进行比较。与朴素算法相比，它避免了大量不必要的字符比较，利用哈希快速筛选可能匹配的位置。
> 2. 滚动哈希通过从当前哈希值中减去最左侧字符的贡献，然后加上新进入窗口字符的贡献来计算。基于数学上的多项式性质，这种计算可以在O(1)时间完成。
> 3. 哈希冲突导致算法需要进行额外的字符比较，降低性能。使用更好的哈希函数、更大的质数模数或多哈希技术来减少冲突。
> 4. 在多模式匹配中，Rabin-Karp可以一次性计算文本串的哈希值，然后与多个模式串的哈希值比较，避免重复扫描文本串。
> 5. 选择哈希函数时应考虑计算效率和冲突概率。大多数情况下使用多项式哈希与大质数模数（如109+7或109+9）组合，在某些情况下也可以使用双哈希或多哈希技术增强安全性。

### 二、Boyer-Moore算法

#### Boyer-Moore算法

Boyer-Moore算法是一种高效的字符串搜索算法，它通过从右向左比较并利用坏字符和好后缀两种规则来跳过不必要的比较，实现比朴素算法更快的搜索速度。

#### 算法讲解

##### 介绍

Boyer-Moore算法是一种高效的字符串匹配算法，由 Robert S. Boyer和J Strother Moore 设计于1977年。它**从右向左比较**字符，并利用两个启发式规则（坏字符规则和好后缀规则）在不匹配情况下实现较大跳跃，减少比较次数。Boyer-Moore算法在实际应用中大部分情况下**比朴素算法和KMP算法更高效**。

#### 算法步骤

1. 预处理模式串，构建坏字符表和好后缀表
2. 将模式串对齐到文本串的开始位置
3. 从模式串的最右侧字符开始比较，从右向左进行匹配
4. 如果发生不匹配，通过以下规则计算跳转距离：
   - 坏字符规则：根据不匹配字符在模式串中的最右位置决定跳转距离
   - 好后缀规则：根据已匹配部分在模式串中的重复情况决定跳转距离
5. 选择两个规则中的最大跳转距离，移动模式串
6. 重复步骤3-5，直到找到匹配或到达文本串末尾

#### 核心特性

- **从右向左比较**：与大多数字符串匹配算法不同，从模式串的末尾开始比较
- **双规则跳转**：利用坏字符规则和好后缀规则计算跳转距离
- **时间复杂度**：最坏情况O(m*n)，m是模式串长度，n是文本串长度；平均情况接近O(n/m)
- **空间复杂度**：O(k+m)，其中k是字符集大小，m是模式串长度
- **适用范围**：特别适合长模式串和大字符集场景

#### 代码实现

```java
public class BoyerMoore {
    private final int R; // 字符集大小
    private int[] badChar; // 坏字符表
    private int[] goodSuffix; // 好后缀表
    private int[] borderPos; // 边界位置表
    private String pattern; // 模式串
    
    public BoyerMoore(String pattern) {
        this.R = 256; // ASCII字符集
        this.pattern = pattern;
        int m = pattern.length();
        
        // 初始化坏字符表
        badChar = new int[R];
        for (int c = 0; c < R; c++) {
            badChar[c] = -1; // 初始化为-1
        }
        for (int j = 0; j < m; j++) {
            badChar[pattern.charAt(j)] = j; // 记录每个字符最右出现位置
        }
        
        // 初始化好后缀表和边界位置表
        goodSuffix = new int[m];
        borderPos = new int[m];
        processSuffixes();
    }
    
    // 预处理好后缀表
    private void processSuffixes() {
        int m = pattern.length();
        int i = m, j = m + 1;
        borderPos[i] = j;
        
        // 计算边界位置
        while (i > 0) {
            while (j <= m && pattern.charAt(i - 1) != pattern.charAt(j - 1)) {
                if (goodSuffix[j] == 0) {
                    goodSuffix[j] = j - i;
                }
                j = borderPos[j];
            }
            i--; j--;
            borderPos[i] = j;
        }
        
        // 计算好后缀表
        j = borderPos[0];
        for (i = 0; i <= m; i++) {
            if (goodSuffix[i] == 0) {
                goodSuffix[i] = j;
            }
            if (i == j) {
                j = borderPos[j];
            }
        }
    }
    
    // 搜索文本串中的匹配
    public int search(String text) {
        int n = text.length();
        int m = pattern.length();
        if (m == 0) return 0;
        
        int skip;
        for (int i = 0; i <= n - m; i += skip) {
            skip = 0;
            for (int j = m - 1; j >= 0; j--) {
                if (pattern.charAt(j) != text.charAt(i + j)) {
                    // 坏字符规则
                    skip = Math.max(1, j - badChar[text.charAt(i + j)]);
                    // 好后缀规则
                    if (j < m - 1) {
                        skip = Math.max(skip, goodSuffix[j + 1]);
                    }
                    break;
                }
            }
            if (skip == 0) return i; // 找到匹配
        }
        return -1; // 没有找到匹配
    }
    
    // 测试
    public static void main(String[] args) {
        String text = "HERE IS A SIMPLE EXAMPLE";
        String pattern = "EXAMPLE";
        
        BoyerMoore bm = new BoyerMoore(pattern);
        int position = bm.search(text);
        
        if (position == -1) {
            System.out.println("未找到匹配");
        } else {
            System.out.println("模式串在位置 " + position + " 处匹配");
            System.out.println(text);
            for (int i = 0; i < position; i++) {
                System.out.print(" ");
            }
            System.out.println(pattern);
        }
    }
}

```

#### 优化策略

##### 简化好后缀表构建

对于一些应用场景，可以只使用坏字符规则，简化算法实现：

```java
▼Java复制代码public class SimplifiedBoyerMoore {
    private final int R; // 字符集大小
    private int[] badChar; // 坏字符表
    private String pattern; // 模式串
    
    public SimplifiedBoyerMoore(String pattern) {
        this.R = 256; // ASCII字符集
        this.pattern = pattern;
        int m = pattern.length();
        
        // 初始化坏字符表
        badChar = new int[R];
        for (int c = 0; c < R; c++) {
            badChar[c] = -1; // 初始化为-1
        }
        for (int j = 0; j < m; j++) {
            badChar[pattern.charAt(j)] = j; // 记录每个字符最右出现位置
        }
    }
    
    // 搜索文本串中的匹配
    public int search(String text) {
        int n = text.length();
        int m = pattern.length();
        if (m == 0) return 0;
        
        int skip;
        for (int i = 0; i <= n - m; i += skip) {
            skip = 0;
            for (int j = m - 1; j >= 0; j--) {
                if (pattern.charAt(j) != text.charAt(i + j)) {
                    // 仅使用坏字符规则
                    skip = Math.max(1, j - badChar[text.charAt(i + j)]);
                    break;
                }
            }
            if (skip == 0) return i; // 找到匹配
        }
        return -1; // 没有找到匹配
    }
}
```

##### 缓存预计算结果

针对需要重复搜索同一模式串的场景，可以预计算并缓存结果：

```java
▼Java复制代码public class CachedBoyerMoore {
    private Map<String, BoyerMoore> cache = new HashMap<>();
    
    public int search(String text, String pattern) {
        // 检查缓存中是否有预计算的Boyer-Moore对象
        BoyerMoore bm = cache.get(pattern);
        if (bm == null) {
            bm = new BoyerMoore(pattern);
            cache.put(pattern, bm);
        }
        
        return bm.search(text);
    }
}
```

#### 优缺点

##### 优点

- 在实际应用中，大部分场景比KMP和朴素算法更高效
- 最好情况下可以跳过大量文本，实现亚线性时间复杂度
- 对于长模式串和大字符集特别有效
- 预处理跟模式串有关，与文本串长度无关

##### 缺点

- 预处理复杂，特别是好后缀表的构建
- 需要额外空间存储坏字符表和好后缀表
- 最坏情况下时间复杂度仍为O(m*n)
- 对于短模式串，预处理开销可能抵消算法优势
- 好后缀规则的实现较复杂，容易出错

#### 应用场景

1）文本编辑器的查找功能

2）网络安全中的特征码匹配

3）自然语言处理中的关键词检索

4）大规模文本数据处理

#### 扩展

##### Horspool算法

Horspool算法是Boyer-Moore的简化版本，只使用坏字符规则，但是对坏字符表进行了修改：

```java
▼Java复制代码public class Horspool {
    private final int R; // 字符集大小
    private int[] badChar; // 坏字符表
    private String pattern; // 模式串
    
    public Horspool(String pattern) {
        this.R = 256; // ASCII字符集
        this.pattern = pattern;
        int m = pattern.length();
        
        // 初始化坏字符表
        badChar = new int[R];
        // 所有字符默认移动模式串长度
        for (int c = 0; c < R; c++) {
            badChar[c] = m;
        }
        // 模式串中的字符（除了最后一个）设置为对应值
        for (int j = 0; j < m - 1; j++) {
            badChar[pattern.charAt(j)] = m - 1 - j;
        }
    }
    
    // 搜索文本串中的匹配
    public int search(String text) {
        int n = text.length();
        int m = pattern.length();
        if (m == 0) return 0;
        if (m > n) return -1;
        
        int i = m - 1; // 从模式串最后一个字符对齐开始
        while (i < n) {
            int k = 0;
            while (k < m && pattern.charAt(m - 1 - k) == text.charAt(i - k)) {
                k++;
            }
            
            if (k == m) {
                return i - m + 1; // 找到匹配
            }
            
            // 使用坏字符规则移动
            i += badChar[text.charAt(i)];
        }
        
        return -1; // 没有找到匹配
    }
}
```

##### Sunday算法

Sunday算法是另一种Boyer-Moore的变种，它关注的是文本串中模式串后面的字符：

```java
▼Java复制代码public class Sunday {
    private final int R; // 字符集大小
    private int[] shift; // 移动表
    private String pattern; // 模式串
    
    public Sunday(String pattern) {
        this.R = 256; // ASCII字符集
        this.pattern = pattern;
        int m = pattern.length();
        
        // 初始化移动表
        shift = new int[R];
        // 所有字符默认移动模式串长度+1
        for (int c = 0; c < R; c++) {
            shift[c] = m + 1;
        }
        // 模式串中的字符设置为对应值
        for (int j = 0; j < m; j++) {
            shift[pattern.charAt(j)] = m - j;
        }
    }
    
    // 搜索文本串中的匹配
    public int search(String text) {
        int n = text.length();
        int m = pattern.length();
        if (m == 0) return 0;
        if (m > n) return -1;
        
        int i = 0; // 从文本串开始位置
        while (i <= n - m) {
            int j = 0;
            while (j < m && pattern.charAt(j) == text.charAt(i + j)) {
                j++;
            }
            
            if (j == m) {
                return i; // 找到匹配
            }
            
            // 下一个位置超出文本串长度，返回-1
            if (i + m >= n) {
                return -1;
            }
            
            // 使用Sunday算法的移动规则
            i += shift[text.charAt(i + m)];
        }
        
        return -1; // 没有找到匹配
    }
}
```

#### 测验

这里准备了一些测试题，方便大家判断自己的掌握情况：

1. Boyer-Moore算法的两个主要启发式规则是什么？
2. 为什么Boyer-Moore算法从右向左比较字符？
3. 在最好情况下，Boyer-Moore算法的时间复杂度是多少？
4. 坏字符规则和好后缀规则如何协同工作？

> 测验答案
>
> 1. 坏字符规则和好后缀规则。
> 2. 从右向左比较可以更快发现不匹配，然后通过坏字符和好后缀规则计算更大的跳转距离。
> 3. 最好情况下Boyer-Moore算法的时间复杂度可以达到O(n/m)。
> 4. 分别计算坏字符规则和好后缀规则跳转距离，然后选择两者中的最大值作为实际跳转距离，保证安全、高效的跳转。

### 三、KMP算法

#### KMP算法

KMP(Knuth-Morris-Pratt)算法是一种高效的字符串匹配算法，通过计算部分匹配表(前缀函数)避免不必要的字符比较，大大提高了字符串匹配的效率。

#### 算法讲解

##### 介绍

KMP（Knuth-Morris-Pratt）算法是一种高效的字符串匹配算法，核心思想是**利用已经部分匹配的信息，避免重复比较**，在文本串中快速查找模式串。KMP算法特别适合**处理长文本和重复性高的模式串**，时间复杂度是O(m+n)，m是模式串长度，n是文本串长度。

KMP算法的关键在于构建一个部分匹配表（也叫失败函数或者next数组），这个表记录了当匹配失败时，模式串指针应该回退到的位置，让算法跳过已知不可能匹配的位置，提高匹配效率。

#### 算法步骤

KMP算法主要分为两个阶段：

1. 预处理阶段

   ：计算模式串的部分匹配表（next数组）

   - 构建一个数组，记录每个位置的最长相等前后缀长度
   - 该数组用于在匹配失败时确定模式串指针的回退位置

2. 匹配阶段

   ：使用部分匹配表在文本串中查找模式串

   - 从左到右同时遍历文本串和模式串
   - 当字符不匹配时，根据next数组回退模式串指针
   - 当模式串完全匹配时，记录匹配位置并继续查找其他匹配

#### 核心特性

- **线性时间复杂度**：O(m+n)，其中m是模式串长度，n是文本串长度
- **高效利用历史信息**：通过预处理避免了重复比较
- **只需一次遍历文本串**：文本串指针不会回退
- **空间复杂度**：O(m)，仅需存储模式串的部分匹配表
- **适用场景**：特别适合长文本和具有重复性的模式串

#### 代码实现

```java
public class NaiveStringMatcher {
    
    /**
     * 朴素字符串匹配算法
     * @param text 文本串
     * @param pattern 模式串
     * @return 匹配成功则返回模式串在文本串中的起始位置，否则返回-1
     */
    public static int naiveSearch(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        
        // 特殊情况处理
        if (m == 0) return 0;
        if (n < m) return -1;
        
        // 尝试所有可能的匹配位置
        for (int i = 0; i <= n - m; i++) {
            int j;
            
            // 从当前位置开始比较模式串和文本串
            for (j = 0; j < m; j++) {
                if (text.charAt(i + j) != pattern.charAt(j)) {
                    break; // 发现不匹配字符，终止内层循环
                }
            }
            
            // 如果j等于m，说明模式串完全匹配
            if (j == m) {
                return i; // 返回匹配位置
            }
        }
        
        return -1; // 未找到匹配
    }
    
    // 使用示例
    public static void main(String[] args) {
        String text = "ABABDABACDABABCABAB";
        String pattern = "ABABCABAB";
        
        int position = naiveSearch(text, pattern);
        
        if (position == -1) {
            System.out.println("未找到匹配");
        } else {
            System.out.println("模式串在位置 " + position + " 处匹配");
        }
    }
}

```

上述实现暴力枚举所有可能的匹配位置，逐一比较文本串与模式串的每个字符，直到找到完全匹配或确定不存在匹配。

接下来展示KMP算法的实现：

##### Java实现

```java
▼Java复制代码public class KMP {
    // 构建部分匹配表（next数组）
    private static int[] buildNext(String pattern) {
        int m = pattern.length();
        int[] next = new int[m];
        next[0] = 0; // 第一个字符的最长相等前后缀长度为0
        
        for (int i = 1, j = 0; i < m; i++) {
            // 当前字符不匹配，回退j
            while (j > 0 && pattern.charAt(i) != pattern.charAt(j)) {
                j = next[j - 1];
            }
            
            // 当前字符匹配，j向前移动
            if (pattern.charAt(i) == pattern.charAt(j)) {
                j++;
            }
            
            // 记录当前位置的最长相等前后缀长度
            next[i] = j;
        }
        
        return next;
    }
    
    // KMP搜索算法
    public static int kmpSearch(String text, String pattern) {
        if (pattern == null || pattern.length() == 0) {
            return 0;
        }
        
        if (text == null || text.length() < pattern.length()) {
            return -1;
        }
        
        int n = text.length();
        int m = pattern.length();
        
        // 构建next数组
        int[] next = buildNext(pattern);
        
        // 进行匹配
        for (int i = 0, j = 0; i < n; i++) {
            // 当前字符不匹配，根据next数组回退j
            while (j > 0 && text.charAt(i) != pattern.charAt(j)) {
                j = next[j - 1];
            }
            
            // 当前字符匹配，j向前移动
            if (text.charAt(i) == pattern.charAt(j)) {
                j++;
            }
            
            // 完全匹配，返回起始索引
            if (j == m) {
                return i - m + 1;
            }
        }
        
        return -1; // 未找到匹配
    }
    
    // 查找所有匹配位置
    public static List<Integer> kmpSearchAll(String text, String pattern) {
        List<Integer> positions = new ArrayList<>();
        if (pattern == null || pattern.length() == 0) {
            return positions;
        }
        
        if (text == null || text.length() < pattern.length()) {
            return positions;
        }
        
        int n = text.length();
        int m = pattern.length();
        
        // 构建next数组
        int[] next = buildNext(pattern);
        
        // 进行匹配
        for (int i = 0, j = 0; i < n; i++) {
            // 当前字符不匹配，回退j
            while (j > 0 && text.charAt(i) != pattern.charAt(j)) {
                j = next[j - 1];
            }
            
            // 当前字符匹配，j向前移动
            if (text.charAt(i) == pattern.charAt(j)) {
                j++;
            }
            
            // 完全匹配，记录位置并继续匹配
            if (j == m) {
                positions.add(i - m + 1);
                // 回退j以寻找下一个匹配
                j = next[j - 1];
            }
        }
        
        return positions;
    }
    
    public static void main(String[] args) {
        String text = "ABABDABACDABABCABAB";
        String pattern = "ABABCABAB";
        
        int pos = kmpSearch(text, pattern);
        List<Integer> allPos = kmpSearchAll(text, pattern);
        
        System.out.println("文本: " + text);
        System.out.println("模式: " + pattern);
        System.out.println("首次匹配位置: " + (pos != -1 ? pos : "未找到"));
        System.out.println("所有匹配位置: " + allPos);
        
        // 打印next数组，帮助理解
        int[] next = buildNext(pattern);
        System.out.print("next数组: ");
        for (int val : next) {
            System.out.print(val + " ");
        }
        System.out.println();
    }
}
```

在上述代码中，

```java
▼Java复制代码// 当前字符不匹配，回退j
while (j > 0 && text.charAt(i) != pattern.charAt(j)) {
    j = next[j - 1];
}
```

是 KMP 算法的核心，在匹配失败时根据预先计算的next数组来确定模式串指针的回退位置。

##### 代码实现

```javascript
        function buildNext(pattern) {
    const m = pattern.length;
    const next = new Array(m).fill(0);
    
    for (let i = 1, j = 0; i < m; i++) {
        while (j > 0 && pattern[i] !== pattern[j]) {
            j = next[j - 1];
        }
        
        if (pattern[i] === pattern[j]) {
            j++;
        }
        
        next[i] = j;
    }
    
    return next;
}

function kmpSearch(text, pattern) {
    if (!pattern || pattern.length === 0) {
        return 0;
    }
    
    if (!text || text.length < pattern.length) {
        return -1;
    }
    
    const n = text.length;
    const m = pattern.length;
    const next = buildNext(pattern);
    
    for (let i = 0, j = 0; i < n; i++) {
        while (j > 0 && text[i] !== pattern[j]) {
            j = next[j - 1];
        }
        
        if (text[i] === pattern[j]) {
            j++;
        }
        
        if (j === m) {
            return i - m + 1;
        }
    }
    
    return -1;
}

// 测试
const text = "ABABDABACDABABCABAB";
const pattern = "ABABCABAB";
console.log(`文本: ${text}`);
console.log(`模式: ${pattern}`);
console.log(`匹配位置: ${kmpSearch(text, pattern)}`);
console.log(`next数组: ${buildNext(pattern).join(' ')}`);
```

##### C语言实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void buildNext(const char* pattern, int* next, int m) {
    next[0] = 0;
    
    for (int i = 1, j = 0; i < m; i++) {
        while (j > 0 && pattern[i] != pattern[j]) {
            j = next[j - 1];
        }
        
        if (pattern[i] == pattern[j]) {
            j++;
        }
        
        next[i] = j;
    }
}

int kmpSearch(const char* text, const char* pattern) {
    if (pattern == NULL || strlen(pattern) == 0) {
        return 0;
    }
    
    if (text == NULL || strlen(text) < strlen(pattern)) {
        return -1;
    }
    
    int n = strlen(text);
    int m = strlen(pattern);
    int* next = (int*)malloc(m * sizeof(int));
    
    buildNext(pattern, next, m);
    
    int j = 0;
    for (int i = 0; i < n; i++) {
        while (j > 0 && text[i] != pattern[j]) {
            j = next[j - 1];
        }
        
        if (text[i] == pattern[j]) {
            j++;
        }
        
        if (j == m) {
            free(next);
            return i - m + 1;
        }
    }
    
    free(next);
    return -1;
}

int main() {
    const char* text = "ABABDABACDABABCABAB";
    const char* pattern = "ABABCABAB";
    
    printf("文本: %s
", text);
    printf("模式: %s
", pattern);
    
    int pos = kmpSearch(text, pattern);
    printf("匹配位置: %d
", pos);
    
    // 打印next数组
    int m = strlen(pattern);
    int* next = (int*)malloc(m * sizeof(int));
    buildNext(pattern, next, m);
    
    printf("next数组: ");
    for (int i = 0; i < m; i++) {
        printf("%d ", next[i]);
    }
    printf("
");
    
    free(next);
    return 0;
}

```

#### 优化策略

优化后的 next 数组代码实现：

```java
▼Java复制代码// 优化next数组，避免匹配失败后回退到同样会失败的位置
private static int[] buildOptimizedNext(String pattern) {
    int m = pattern.length();
    int[] next = new int[m];
    next[0] = 0;
    
    for (int i = 1, j = 0; i < m; i++) {
        while (j > 0 && pattern.charAt(i) != pattern.charAt(j)) {
            j = next[j - 1];
        }
        
        if (pattern.charAt(i) == pattern.charAt(j)) {
            j++;
        }
        
        // 当前位置匹配失败时，如果回退位置的字符与当前位置相同，则继续回退
        if (i + 1 < m && pattern.charAt(i + 1) == pattern.charAt(j)) {
            next[i] = next[j - 1];
        } else {
            next[i] = j;
        }
    }
    
    return next;
}
```

预处理减少分支实现：

```java
▼Java复制代码// 预处理字符映射，减少字符比较的分支
public static int kmpSearchOptimized(String text, String pattern) {
    if (pattern == null || pattern.length() == 0) {
        return 0;
    }
    
    if (text == null || text.length() < pattern.length()) {
        return -1;
    }
    
    int n = text.length();
    int m = pattern.length();
    
    // 使用数组映射来加速字符比较（假设字符集为ASCII）
    // 为每个模式字符的每个位置创建一个状态转移表
    int[][] dfa = new int[256][m];
    
    // 初始化第一个字符的DFA
    dfa[pattern.charAt(0)][0] = 1;
    
    for (int X = 0, j = 1; j < m; j++) {
        // 复制匹配失败情况下的值
        for (int c = 0; c < 256; c++) {
            dfa[c][j] = dfa[c][X];
        }
        // 设置匹配成功情况下的值
        dfa[pattern.charAt(j)][j] = j + 1;
        // 更新重启状态
        X = dfa[pattern.charAt(j)][X];
    }
    
    // 模式匹配
    int i, j;
    for (i = 0, j = 0; i < n && j < m; i++) {
        j = dfa[text.charAt(i)][j];
    }
    
    if (j == m) {
        return i - m; // 找到匹配
    } else {
        return -1;    // 未找到匹配
    }
}
```

#### 优缺点

##### 优点

- 时间复杂度为O(m+n)，优于朴素的字符串匹配算法(暴力解法)
- 文本串只需扫描一次，不会回退
- 对于包含重复模式的字符串会高效
- 预处理模式串，可以多次用于不同的文本串
- 能快速跳过已知不会匹配的位置

##### 缺点

- 需要额外的空间存储next数组
- 构建next数组的逻辑较为复杂，不易理解
- 在模式串较短或无重复模式时，相比简单算法优势不明显
- 实现时容易出错，特别是处理边界情况

#### 应用场景

1）生物信息学中的DNA序列匹配

2）网络入侵检测系统中的模式匹配

3）搜索引擎的关键词匹配

4）数据压缩算法中的模式识别

#### 扩展

##### 多模式字符串匹配

```java
        // Aho-Corasick算法 - KMP的多模式扩展
public static class AhoCorasick {
    static class TrieNode {
        TrieNode[] children = new TrieNode[256];
        TrieNode fail;
        List<Integer> patternIndices = new ArrayList<>();
        
        public TrieNode() {
            fail = null;
        }
    }
    
    private TrieNode root;
    private String[] patterns;
    
    public AhoCorasick(String[] patterns) {
        this.patterns = patterns;
        buildTrie();
        buildFailureLinks();
    }
    
    private void buildTrie() {
        root = new TrieNode();
        
        for (int i = 0; i < patterns.length; i++) {
            String pattern = patterns[i];
            TrieNode node = root;
            
            for (char c : pattern.toCharArray()) {
                if (node.children[c] == null) {
                    node.children[c] = new TrieNode();
                }
                node = node.children[c];
            }
            
            node.patternIndices.add(i);
        }
    }
    
    private void buildFailureLinks() {
        Queue<TrieNode> queue = new LinkedList<>();
        
        // 初始化根节点的子节点
        for (int i = 0; i < 256; i++) {
            if (root.children[i] != null) {
                root.children[i].fail = root;
                queue.offer(root.children[i]);
            } else {
                root.children[i] = root;
            }
        }
        
        // BFS构建失败链接
        while (!queue.isEmpty()) {
            TrieNode node = queue.poll();
            
            for (int i = 0; i < 256; i++) {
                if (node.children[i] != null) {
                    TrieNode failNode = node.fail;
                    
                    while (failNode != root && failNode.children[i] == null) {
                        failNode = failNode.fail;
                    }
                    
                    failNode = failNode.children[i];
                    node.children[i].fail = failNode;
                    
                    // 合并匹配结果
                    node.children[i].patternIndices.addAll(failNode.patternIndices);
                    
                    queue.offer(node.children[i]);
                }
            }
        }
    }
    
    public List<Pair<Integer, Integer>> search(String text) {
        List<Pair<Integer, Integer>> results = new ArrayList<>();
        TrieNode currentState = root;
        
        for (int i = 0; i < text.length(); i++) {
            char c = text.charAt(i);
            
            while (currentState != root && currentState.children[c] == null) {
                currentState = currentState.fail;
            }
            
            currentState = currentState.children[c];
            
            for (int patternIndex : currentState.patternIndices) {
                int endPos = i;
                int startPos = endPos - patterns[patternIndex].length() + 1;
                results.add(new Pair<>(patternIndex, startPos));
            }
        }
        
        return results;
    }
    
    static class Pair<K, V> {
        K first;
        V second;
        
        public Pair(K first, V second) {
            this.first = first;
            this.second = second;
        }
    }
}

      
```

#### 测验

这里准备了一些测试题，方便大家判断自己的掌握情况：

1. KMP算法的时间复杂度是多少？它与暴力匹配算法的主要区别是什么？
2. KMP算法中next数组的含义是什么？如何利用它避免不必要的比较？
3. 在KMP算法中，文本指针是否会回退？为什么？

> 测验答案
>
> 1. KMP算法的时间复杂度是O(m+n)，其中m是模式串长度，n是文本串长度。与暴力匹配算法O(m*n)相比，KMP算法利用已匹配信息避免重复比较，文本指针不会回退。
> 2. next数组记录了模式串中每个位置的最长相等前后缀长度，表示当匹配失败时，模式串指针应该回退到的位置。通过跳过已知不可能匹配的位置，实现减少不必要的比较次数。
> 3. 文本指针不会回退，只有模式串指针会根据next数组回退。因为KMP算法的核心思想就是利用已经部分匹配的信息，避免对文本串的重复扫描。

#### 扩展

##### 多模式字符串匹配

```java
        // Aho-Corasick算法 - KMP的多模式扩展
public static class AhoCorasick {
    static class TrieNode {
        TrieNode[] children = new TrieNode[256];
        TrieNode fail;
        List<Integer> patternIndices = new ArrayList<>();
        
        public TrieNode() {
            fail = null;
        }
    }
    
    private TrieNode root;
    private String[] patterns;
    
    public AhoCorasick(String[] patterns) {
        this.patterns = patterns;
        buildTrie();
        buildFailureLinks();
    }
    
    private void buildTrie() {
        root = new TrieNode();
        
        for (int i = 0; i < patterns.length; i++) {
            String pattern = patterns[i];
            TrieNode node = root;
            
            for (char c : pattern.toCharArray()) {
                if (node.children[c] == null) {
                    node.children[c] = new TrieNode();
                }
                node = node.children[c];
            }
            
            node.patternIndices.add(i);
        }
    }
    
    private void buildFailureLinks() {
        Queue<TrieNode> queue = new LinkedList<>();
        
        // 初始化根节点的子节点
        for (int i = 0; i < 256; i++) {
            if (root.children[i] != null) {
                root.children[i].fail = root;
                queue.offer(root.children[i]);
            } else {
                root.children[i] = root;
            }
        }
        
        // BFS构建失败链接
        while (!queue.isEmpty()) {
            TrieNode node = queue.poll();
            
            for (int i = 0; i < 256; i++) {
                if (node.children[i] != null) {
                    TrieNode failNode = node.fail;
                    
                    while (failNode != root && failNode.children[i] == null) {
                        failNode = failNode.fail;
                    }
                    
                    failNode = failNode.children[i];
                    node.children[i].fail = failNode;
                    
                    // 合并匹配结果
                    node.children[i].patternIndices.addAll(failNode.patternIndices);
                    
                    queue.offer(node.children[i]);
                }
            }
        }
    }
    
    public List<Pair<Integer, Integer>> search(String text) {
        List<Pair<Integer, Integer>> results = new ArrayList<>();
        TrieNode currentState = root;
        
        for (int i = 0; i < text.length(); i++) {
            char c = text.charAt(i);
            
            while (currentState != root && currentState.children[c] == null) {
                currentState = currentState.fail;
            }
            
            currentState = currentState.children[c];
            
            for (int patternIndex : currentState.patternIndices) {
                int endPos = i;
                int startPos = endPos - patterns[patternIndex].length() + 1;
                results.add(new Pair<>(patternIndex, startPos));
            }
        }
        
        return results;
    }
    
    static class Pair<K, V> {
        K first;
        V second;
        
        public Pair(K first, V second) {
            this.first = first;
            this.second = second;
        }
    }
}

      
```

#### 测验

这里准备了一些测试题，方便大家判断自己的掌握情况：

1. KMP算法的时间复杂度是多少？它与暴力匹配算法的主要区别是什么？
2. KMP算法中next数组的含义是什么？如何利用它避免不必要的比较？
3. 在KMP算法中，文本指针是否会回退？为什么？

> 测验答案
>
> 1. KMP算法的时间复杂度是O(m+n)，其中m是模式串长度，n是文本串长度。与暴力匹配算法O(m*n)相比，KMP算法利用已匹配信息避免重复比较，文本指针不会回退。
> 2. next数组记录了模式串中每个位置的最长相等前后缀长度，表示当匹配失败时，模式串指针应该回退到的位置。通过跳过已知不可能匹配的位置，实现减少不必要的比较次数。
> 3. 文本指针不会回退，只有模式串指针会根据next数组回退。因为KMP算法的核心思想就是利用已经部分匹配的信息，避免对文本串的重复扫描。

#### 扩展

##### 多模式字符串匹配

```java
        // Aho-Corasick算法 - KMP的多模式扩展
public static class AhoCorasick {
    static class TrieNode {
        TrieNode[] children = new TrieNode[256];
        TrieNode fail;
        List<Integer> patternIndices = new ArrayList<>();
        
        public TrieNode() {
            fail = null;
        }
    }
    
    private TrieNode root;
    private String[] patterns;
    
    public AhoCorasick(String[] patterns) {
        this.patterns = patterns;
        buildTrie();
        buildFailureLinks();
    }
    
    private void buildTrie() {
        root = new TrieNode();
        
        for (int i = 0; i < patterns.length; i++) {
            String pattern = patterns[i];
            TrieNode node = root;
            
            for (char c : pattern.toCharArray()) {
                if (node.children[c] == null) {
                    node.children[c] = new TrieNode();
                }
                node = node.children[c];
            }
            
            node.patternIndices.add(i);
        }
    }
    
    private void buildFailureLinks() {
        Queue<TrieNode> queue = new LinkedList<>();
        
        // 初始化根节点的子节点
        for (int i = 0; i < 256; i++) {
            if (root.children[i] != null) {
                root.children[i].fail = root;
                queue.offer(root.children[i]);
            } else {
                root.children[i] = root;
            }
        }
        
        // BFS构建失败链接
        while (!queue.isEmpty()) {
            TrieNode node = queue.poll();
            
            for (int i = 0; i < 256; i++) {
                if (node.children[i] != null) {
                    TrieNode failNode = node.fail;
                    
                    while (failNode != root && failNode.children[i] == null) {
                        failNode = failNode.fail;
                    }
                    
                    failNode = failNode.children[i];
                    node.children[i].fail = failNode;
                    
                    // 合并匹配结果
                    node.children[i].patternIndices.addAll(failNode.patternIndices);
                    
                    queue.offer(node.children[i]);
                }
            }
        }
    }
    
    public List<Pair<Integer, Integer>> search(String text) {
        List<Pair<Integer, Integer>> results = new ArrayList<>();
        TrieNode currentState = root;
        
        for (int i = 0; i < text.length(); i++) {
            char c = text.charAt(i);
            
            while (currentState != root && currentState.children[c] == null) {
                currentState = currentState.fail;
            }
            
            currentState = currentState.children[c];
            
            for (int patternIndex : currentState.patternIndices) {
                int endPos = i;
                int startPos = endPos - patterns[patternIndex].length() + 1;
                results.add(new Pair<>(patternIndex, startPos));
            }
        }
        
        return results;
    }
    
    static class Pair<K, V> {
        K first;
        V second;
        
        public Pair(K first, V second) {
            this.first = first;
            this.second = second;
        }
    }
}

      
```

#### 测验

这里准备了一些测试题，方便大家判断自己的掌握情况：

1. KMP算法的时间复杂度是多少？它与暴力匹配算法的主要区别是什么？
2. KMP算法中next数组的含义是什么？如何利用它避免不必要的比较？
3. 在KMP算法中，文本指针是否会回退？为什么？

> 测验答案
>
> 1. KMP算法的时间复杂度是O(m+n)，其中m是模式串长度，n是文本串长度。与暴力匹配算法O(m*n)相比，KMP算法利用已匹配信息避免重复比较，文本指针不会回退。
> 2. next数组记录了模式串中每个位置的最长相等前后缀长度，表示当匹配失败时，模式串指针应该回退到的位置。通过跳过已知不可能匹配的位置，实现减少不必要的比较次数。
> 3. 文本指针不会回退，只有模式串指针会根据next数组回退。因为KMP算法的核心思想就是利用已经部分匹配的信息，避免对文本串的重复扫描。

## 递归与分治算法

### 一、递归算法

#### 递归算法

递归是一种函数调用自身的编程技术，通过将大问题分解为相同形式的小问题来解决。递归依赖函数调用栈，适用于具有自相似结构的问题，如阶乘计算和树结构遍历。

```时间复杂度:最佳 问题相关 | 平均 问题相关 | 最差 问题相关   空间复杂度:O(n)```

>##### 应用场景/前提条件
>
>- 需要明确的基准情况（终止条件）
>- 递归调用必须朝着基准情况方向发展

#### 算法讲解

##### 介绍

递归算法（Recursion Algorithm）是一种重要的编程方法，核心思想是**函数通过调用自身**来解决问题。在递归中，一个复杂的问题被分解为相同类型但规模更小的子问题，直到达到一个简单到可以直接解决的基本情况（基准情况）。递归算法特别适合**解决具有自相似结构的问题**，时间复杂度跟递归深度和每层处理的复杂度有关。

递归算法的妙处在于它能用简洁优雅的代码解决看似复杂的问题，但在使用时一定要注意**避免无限递归**和重复计算等问题。

#### 算法步骤

1. 定义递归函数，明确函数的功能和参数
2. 确定递归的基准情况（终止条件）
3. 将问题分解为更小的子问题
4. 调用自身解决子问题
5. 将子问题的结果组合起来，得到原问题的解

下图以阶乘为例，展示递归流程：

![img](https://bu.dusays.com/2025/09/21/68d00225eb1f0.webp)

#### 核心特性

- **自我调用**：函数在其定义中直接或间接调用自身
- **终止条件**：必须有基准情况使递归能够终止
- **问题分解**：将大问题分解为相同类型但规模更小的子问题
- **时间复杂度**：与递归深度和每层处理的工作量相关
- **空间复杂度**：受函数调用栈深度影响，通常与递归深度成正比

#### 代码实现

通过阶乘（factorial）计算来展示递归算法的实现：

```java
public class Factorial {
    public static int factorial(int n) {
        // 基准情况
        if (n == 0 || n == 1) {
            return 1;
        }
        
        // 递归情况：n! = n * (n-1)!
        return n * factorial(n - 1);
    }
    
    // 测试
    public static void main(String[] args) {
        for (int i = 0; i <= 10; i++) {
            System.out.printf("%d! = %d
", i, factorial(i));
        }
    }
}

```

在上述代码中，通过：

```java
// 递归情况：n! = n * (n-1)!
return n * factorial(n - 1);
```

实现递归的核心思想，将计算 n! 的问题转化为计算 (n-1)! 的子问题。同时设置清晰的终止条件 `if (n == 0 || n == 1) return 1;` 确保递归能够结束。

```javascript
function factorial(n) {
    // 基准情况
    if (n === 0 || n === 1) {
        return 1;
    }
    
    // 递归情况
    return n * factorial(n - 1);
}

// 测试
for (let i = 0; i <= 10; i++) {
    console.log(`${i}! = ${factorial(i)}`);
}
```

#### 优化策略

##### 尾递归优化

通过将递归操作放在函数返回位置，可以被编译器优化，避免额外的栈空间消耗：

```java
▼Java复制代码public static int factorialTailRecursive(int n) {
    return factorialHelper(n, 1);
}

private static int factorialHelper(int n, int accumulator) {
    // 基准情况
    if (n == 0 || n == 1) {
        return accumulator;
    }
    
    // 尾递归调用
    return factorialHelper(n - 1, n * accumulator);
}
```

##### 记忆化递归

缓存已计算结果，避免重复计算：

```java
▼Java复制代码public static int factorialMemoization(int n) {
    int[] memo = new int[n + 1];
    return factorialWithMemo(n, memo);
}

private static int factorialWithMemo(int n, int[] memo) {
    // 基准情况
    if (n == 0 || n == 1) {
        return 1;
    }
    
    // 检查是否已计算
    if (memo[n] != 0) {
        return memo[n];
    }
    
    // 计算并缓存结果
    memo[n] = n * factorialWithMemo(n - 1, memo);
    return memo[n];
}
```

#### 优缺点

##### 优点

- 代码简洁优雅，易于理解和实现
- 适合处理树、图等具有递归结构的数据
- 某些问题用递归比迭代更直观（比如树的遍历）

##### 缺点

- 函数调用开销较大，会影响性能
- 递归深度过大时可能导致栈溢出
- 重复计算子问题可能导致指数级时间复杂度
- 调试和跟踪执行流程较为困难
- 资源消耗（特别是栈空间）随递归深度增加

#### 应用场景

1）数学计算：阶乘、斐波那契数列、组合数等

2）数据结构操作：树的遍历、图的搜索（DFS）

3）分治算法：归并排序、快速排序

4）动态规划：子问题的递归求解

5）回溯算法：排列组合、八皇后、数独求解

#### 扩展		

##### 斐波那契数列递归实现

```java
        public static int fibonacci(int n) {
    // 基准情况
    if (n <= 1) {
        return n;
    }
    
    // 递归情况：F(n) = F(n-1) + F(n-2)
    return fibonacci(n - 1) + fibonacci(n - 2);
}

      
```

#### 测验

这里准备了一些测试题，方便大家判断自己的掌握情况：

1. 递归算法必须包含哪两个关键部分？为什么它们很重要？
2. 尾递归与普通递归有什么区别？它有什么优势？

> 测验答案
>
> 1. 递归算法必须包含基准情况（终止条件）和递归情况。基准情况确保递归能够终止，避免无限递归；递归情况将问题分解为更小的子问题。
> 2. 尾递归是指递归调用是函数体中最后执行的操作。尾递归可以被编译器优化，通过重用当前栈帧降低空间复杂度，避免栈溢出。

### 二、分治算法

#### 分治算法

分治是一种解决复杂问题的策略，将问题分解为多个相似的子问题，分别解决后再合并结果。这种方法有效降低问题复杂度，常用于排序、搜索等领域，如归并排序和快速排序。

`时间复杂度:最佳 O(n log n) | 最差 O(n log n)   空间复杂度:O(n)`

#### 算法讲解

##### 介绍

分治法(Divide and Conquer)是一种解决复杂问题的重要算法思想，其核心思想是将一个难以直接解决的大问题，分割成若干个规模较小的子问题，以便各个击破，最后将子问题的解组合起来，得到原问题的解。分治法的思想可以追溯到古代，但作为一种系统化的算法策略，它在计算机科学领域得到了极大的发展和应用。

#### 算法步骤

分治算法通常遵循以下三个步骤：

1. 分解(Divide)：将原问题分解为若干个规模较小、相互独立、与原问题形式相同的子问题。
2. 解决(Conquer)：若子问题规模较小且容易解决则直接解决，否则递归地解各子问题。
3. 合并(Combine)：将各子问题的解合并为原问题的解。

#### 核心特性

- 递归结构：分治算法通常使用递归实现，每个子问题继续分解直到达到基本情况
- 独立性：各子问题之间相互独立，不存在交叠
- 问题等价性：子问题与原问题形式相同，只是规模减小
- 合并操作：需要有效的合并子问题解的方法
- 基本情况处理：当问题规模小到一定程度，可以直接求解

#### 优缺点

##### 优点

- 高效性：对于许多问题，分治算法能提供较高的效率
- 并行计算：分治算法天然适合并行计算，各子问题可以独立求解
- 模块化：问题划分为相互独立的模块，便于理解和实现
- 可复用性：同样的分治模式可以应用于多种问题求解

##### 缺点

- 递归开销：递归调用会导致额外的函数调用开销和栈空间使用
- 内存使用：某些分治算法实现可能需要额外的内存空间
- 不适用性：不是所有问题都适合使用分治策略，尤其是子问题不独立的情况
- 合并难度：某些问题的子问题解合并起来可能相当复杂

#### 应用场景

- 排序算法：归并排序、快速排序
- 搜索算法：二分搜索
- 矩阵运算：Strassen矩阵乘法
- 傅里叶变换：快速傅里叶变换(FFT)
- 最近点对问题：计算几何中的经典问题
- 大整数乘法：Karatsuba算法
- 棋盘覆盖问题：使用L型骨牌覆盖棋盘
- 图算法：最短路径、最小生成树等问题

#### 测验

1. 请简述分治算法的三个基本步骤，并说明每个步骤的目的。
2. 归并排序是分治算法的典型应用，请分析归并排序算法中"分"和"治"的过程分别体现在哪里，以及合并阶段的主要挑战是什么？
3. 考虑一个数组中寻找最大子数组和的问题，请描述如何使用分治策略解决这个问题，并分析其时间复杂度。
4. 分治算法和动态规划都可以解决一些重叠子问题，请解释它们之间的主要区别，并给出一个适合分治但不适合动态规划的问题例子。

> 测验答案
>
> 1. (1)分解：将原问题分解为较小的子问题；目的是简化问题难度。(2)解决：递归地解决各个子问题；目的是获取子问题的解。(3)合并：将子问题的解合并成原问题的解；目的是构建完整解决方案。
> 2. 在归并排序中，"分"体现在将数组不断二分直到单个元素的过程，"治"体现在递归地对左右子数组排序。合并阶段的主要挑战是如何高效地合并两个已排序的子数组，需要额外的空间来临时存储元素，并通过比较元素大小来合并。
> 3. 将数组分成左右两半，递归计算左半部分的最大子数组和、右半部分的最大子数组和，以及跨越中点的最大子数组和（需要从中点向两侧扫描），最后返回三者的最大值。时间复杂度为O(n log n)，因为每层分解需要O(n)时间合并，共有log n层。
> 4. 分治算法通常是自顶向下的递归过程，子问题相互独立；而动态规划通常自底向上迭代求解，子问题有重叠且保存子问题解以避免重复计算。适合分治但不适合动态规划的例子是归并排序，因为排序过程中子问题是独立的，没有重叠子问题需要记忆化。

### 三、汉诺塔问题

#### 汉诺塔问题

汉诺塔是一个经典的递归问题，有三根柱子和一系列从大到小叠放的圆盘。目标是将所有圆盘从一根柱子移动到另一根柱子，同时遵循规则：一次只能移动一个圆盘，且不能将大圆盘放在小圆盘上面。

`时间复杂度:最佳 O(2^n) | 平均 O(2^n) | 最差 O(2^n)    空间复杂度:O(n)`

>##### 应用场景/前提条件
>
>- 递归思想
>- 分治策略

#### 算法讲解

##### 介绍

汉诺塔（Tower of Hanoi）是一个源于印度的古老数学智力游戏。这个问题的核心是**将一组按照大小顺序叠放的圆盘从一根柱子移动到另一根柱子**，过程中必须遵循特定规则。汉诺塔问题是**递归算法的经典应用**，也是计算机科学中讲解递归思想的标准案例之一。

这个问题背后隐藏着数学原理，最优解的移动次数是2^n-1（n为圆盘数量），呈指数级增长，所以也常被用来解释为什么某些问题在规模增长时处理难度为陡增。

#### 算法步骤

汉诺塔问题的规则如下：

1. 有三根柱子（通常称为A、B、C），开始时所有圆盘都按照从大到小的顺序叠放在A柱上
2. 每次只能移动一个圆盘，且只能移动最顶端的圆盘
3. 任何时刻都不能将大圆盘放在小圆盘上面
4. 目标是将所有圆盘从A柱按照原有顺序移动到C柱

递归解决汉诺塔问题的思路：

1. **基准情况**：当n=1时，直接将圆盘从源柱(A)移动到目标柱(C)

2. 递归情况

   ：当n>1时

   - 将n-1个圆盘从源柱(A)移动到辅助柱(B)，此时可将目标柱(C)作为辅助
   - 将最大的圆盘(第n个)从源柱(A)移动到目标柱(C)
   - 将n-1个圆盘从辅助柱(B)移动到目标柱(C)，此时可将源柱(A)作为辅助

这种递归策略将问题不断分解为更小规模的相同问题，直到达到易于解决的基准情况。每个移动步骤都保证遵循问题规则，最终完成所有圆盘的移动。

总移动次数满足公式：T(n) = 2^n - 1，其中n为圆盘数量。

![img](https://bu.dusays.com/2025/09/21/68d003c06123a.webp)

#### 核心特性

- **递归结构**：问题可以分解为更小规模的相同问题
- **时间复杂度**：O(2^n)，n是圆盘数量
- **空间复杂度**：O(n)，递归栈的深度
- **确定性**：无论如何操作，最少需要2^n-1步才能完成

#### 代码实现

###### Java实现

```java
▼Java复制代码public class TowerOfHanoi {
    public static void hanoi(int n, char source, char auxiliary, char target) {
        // 基准情况：只有一个圆盘
        if (n == 1) {
            System.out.println("移动圆盘 1 从 " + source + " 到 " + target);
            return;
        }
        
        // 将n-1个圆盘从源柱移动到辅助柱
        hanoi(n - 1, source, target, auxiliary);
        
        // 将第n个圆盘从源柱移动到目标柱
        System.out.println("移动圆盘 " + n + " 从 " + source + " 到 " + target);
        
        // 将n-1个圆盘从辅助柱移动到目标柱
        hanoi(n - 1, auxiliary, source, target);
    }
    
    public static void main(String[] args) {
        int n = 3; // 圆盘数量
        System.out.println("汉诺塔问题 - " + n + " 个圆盘:");
        hanoi(n, 'A', 'B', 'C');
        System.out.println("完成移动，共需要 " + ((1 << n) - 1) + " 步");
    }
}
```

在上述代码中，通过：

```java
▼Java复制代码hanoi(n - 1, source, target, auxiliary);
System.out.println("移动圆盘 " + n + " 从 " + source + " 到 " + target);
hanoi(n - 1, auxiliary, source, target);
```

实现了汉诺塔问题的递归解法。先将n-1个圆盘从源柱移动到辅助柱，然后将最大的圆盘从源柱移动到目标柱，最后将n-1个圆盘从辅助柱移动到目标柱。

```javascript
        function hanoi(n, source, auxiliary, target) {
    // 基准情况：只有一个圆盘
    if (n === 1) {
        console.log(`移动圆盘 1 从 ${source} 到 ${target}`);
        return;
    }
    
    // 将n-1个圆盘从源柱移动到辅助柱
    hanoi(n - 1, source, target, auxiliary);
    
    // 将第n个圆盘从源柱移动到目标柱
    console.log(`移动圆盘 ${n} 从 ${source} 到 ${target}`);
    
    // 将n-1个圆盘从辅助柱移动到目标柱
    hanoi(n - 1, auxiliary, source, target);
}

// 测试
const n = 3;
console.log(`汉诺塔问题 - ${n} 个圆盘:`);
hanoi(n, 'A', 'B', 'C');
console.log(`完成移动，共需要 ${(1 << n) - 1} 步`);

      
```

#### 应用场景

1）递归算法教学与演示

2）计算机科学基础理论研究

3）游戏开发（益智游戏、智力挑战）

4）问题分解策略的示例

5）类似问题的解决思路参考

#### 扩展

##### 广义汉诺塔问题

```java
        // 广义汉诺塔：有四根柱子的情况
public static void fourPegHanoi(int n, char source, char auxiliary1, char auxiliary2, char target) {
    if (n == 0) {
        return;
    }
    
    if (n == 1) {
        System.out.println("移动圆盘 1 从 " + source + " 到 " + target);
        return;
    }
    
    // 计算最优划分点k
    int k = (int)Math.sqrt(2 * n + 1);
    
    // 将上面的n-k个圆盘从源柱移动到第一个辅助柱
    fourPegHanoi(n - k, source, auxiliary2, target, auxiliary1);
    
    // 将下面的k个圆盘从源柱移动到目标柱（使用经典三柱汉诺塔算法）
    hanoi(k, source, auxiliary2, target);
    
    // 将之前移到第一个辅助柱的n-k个圆盘移动到目标柱
    fourPegHanoi(n - k, auxiliary1, source, auxiliary2, target);
}

      
```

#### 测验

这里准备了一些测试题，方便大家判断自己的掌握情况：

1. 对于n个圆盘的汉诺塔问题，最少需要多少步才能完成？请给出数学表达式。
2. 如果有四根柱子，求解汉诺塔问题的最少步数是否仍然是2^n-1？为什么？

> 测验答案
>
> 1. 最少需要2^n-1步才能完成，可以通过递归关系式T(n) = 2T(n-1) + 1得到，其中T(1) = 1。
> 2. 不再是2n-1。四柱汉诺塔问题（也称为Reve's puzzle）的最优解法仍是一个开放问题，但已知最少步数小于2n-1。一种算法将n个圆盘分成k和n-k两部分，然后使用额外的柱子优化移动过程。

### 四、最大子数组问题

#### 最大子数组问题

最大子数组问题是寻找数组中具有最大和的连续子数组。分治法通过将数组分成两半，分别求解左右子数组的最大子数组和跨越中点的最大子数组，然后选择三者中的最大值。

`时间复杂度:最佳 O(n) | 平均 O(n log n) | 最差 O(n log n)   空间复杂度:O(log n)`

>##### 应用场景/前提条件
>
>- 递归
>- 分治策略

#### 算法讲解

##### 介绍

最大子数组问题（Maximum Subarray Problem）是算法设计中的一个经典问题，核心目标是**在一个整数数组中找到一个具有最大和的连续子数组**。最大子数组问题在计算机科学、金融分析、图像处理等多个领域有着广泛应用。

这个问题看似简单，但包含了丰富的算法思想，可以用暴力法、分治法、动态规划等多种方法求解，是理解算法设计范式的绝佳案例。

#### 算法步骤

根据不同的思路，这个问题有不同的解法：

##### 1. 动态规划

1. 初始化两个变量：`maxSoFar`（全局最大和）和 `maxEndingHere`（以当前位置结尾的最大和）
2. 遍历数组，对每个元素:
   - 更新 `maxEndingHere = max(nums[i], maxEndingHere + nums[i])`
   - 更新 `maxSoFar = max(maxSoFar, maxEndingHere)`
3. 返回 `maxSoFar` 作为结果

![img](https://bu.dusays.com/2025/09/21/68d0052c775bf.webp)

##### 2. 分治法

1. 把数组分成左右两半
2. 递归计算左半部分的最大子数组和
3. 递归计算右半部分的最大子数组和
4. 计算跨越中点的最大子数组和
5. 返回三者中的最大值

##### 3. 暴力法

1. 枚举所有可能的子数组（两层循环）
2. 计算每个子数组的和
3. 追踪并返回最大和

#### 核心特性

- **连续性**：要求子数组必须是原数组中的连续元素
- **最优子结构**：当前位置的最优解可以由前一位置的最优解推导
- **时间复杂度**：最优为 O(n)
- **适用条件**：适用于整数数组（包含正负数）

#### 代码实现

```java
public class MaxSubArray {
    public static int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        int maxSoFar = nums[0];
        int maxEndingHere = nums[0];
        
        for (int i = 1; i < nums.length; i++) {
            // 选择当前元素，或将当前元素加入到现有子数组
            maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);
            // 更新全局最大和
            maxSoFar = Math.max(maxSoFar, maxEndingHere);
        }
        
        return maxSoFar;
    }
    
    public static void main(String[] args) {
        int[] arr1 = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        System.out.println("最大子数组和: " + maxSubArray(arr1)); // 输出: 6 (子数组 [4, -1, 2, 1])
        
        int[] arr2 = {1};
        System.out.println("最大子数组和: " + maxSubArray(arr2)); // 输出: 1
        
        int[] arr3 = {5, 4, -1, 7, 8};
        System.out.println("最大子数组和: " + maxSubArray(arr3)); // 输出: 23 (整个数组)
    }
}

```

在上述代码中，通过：

```java
▼Java复制代码maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);
maxSoFar = Math.max(maxSoFar, maxEndingHere);
```

实现了动态规划的状态转移方程，每次决定是重新开始一个子数组还是将当前元素加入已有子数组。

▼

JavaJavascriptPythonGoCC++JavaJava

复制代码

```java
        public class MaxSubArrayDivideConquer {
    public static int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        return maxSubArrayHelper(nums, 0, nums.length - 1);
    }
    
    private static int maxSubArrayHelper(int[] nums, int left, int right) {
        // 基本情况
        if (left == right) {
            return nums[left];
        }
        
        // 分解问题
        int mid = left + (right - left) / 2;
        
        // 计算左半部分的最大子数组和
        int leftMax = maxSubArrayHelper(nums, left, mid);
        
        // 计算右半部分的最大子数组和
        int rightMax = maxSubArrayHelper(nums, mid + 1, right);
        
        // 计算跨中点的最大子数组和
        int crossMax = maxCrossingSubArray(nums, left, mid, right);
        
        // 返回三者中的最大值
        return Math.max(Math.max(leftMax, rightMax), crossMax);
    }
    
    private static int maxCrossingSubArray(int[] nums, int left, int mid, int right) {
        // 计算包含mid的左半部分最大和
        int leftSum = 0;
        int maxLeftSum = Integer.MIN_VALUE;
        
        for (int i = mid; i >= left; i--) {
            leftSum += nums[i];
            maxLeftSum = Math.max(maxLeftSum, leftSum);
        }
        
        // 计算包含mid+1的右半部分最大和
        int rightSum = 0;
        int maxRightSum = Integer.MIN_VALUE;
        
        for (int i = mid + 1; i <= right; i++) {
            rightSum += nums[i];
            maxRightSum = Math.max(maxRightSum, rightSum);
        }
        
        // 返回跨中点的最大子数组和
        return maxLeftSum + maxRightSum;
    }
    
    public static void main(String[] args) {
        int[] arr = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        System.out.println("最大子数组和: " + maxSubArray(arr)); // 输出: 6
    }
}

      
```

#### 优缺点

##### 不同方法的优缺点

##### Kadane算法（动态规划）

**优点**：

- 时间复杂度为O(n)，最优解法
- 空间复杂度为O(1)，只需要常数额外空间
- 只需要一次遍历数组
- 实现简单，代码简洁

**缺点**：

- 不容易扩展，比如扩展到二维数组的情况
- 原始版本不能处理"最大子数组必须非空"的约束

##### 分治法

**优点**：

- 思路清晰，容易推广到类似的问题
- 可以并行计算，提高效率

**缺点**：

- 时间复杂度为O(n log n)，不如动态规划
- 需要递归调用，空间复杂度为O(log n)
- 实现相对复杂

##### 暴力法

###### **优点**：

- 直观易懂
- 容易实现和调试
- 适用于小规模数据

###### **缺点**：

- 时间复杂度为O(n²)或O(n³)（取决于实现方式）
- 在大规模数据上效率极低
- 不适合实际应用

#### 应用场景

1）股票交易分析：寻找最大收益区间

2）图像处理：识别图像中的特定区域

3）数据分析：查找数据序列中的显著模式

4）生物信息学：DNA序列分析

5）信号处理：检测信号中的重要片段

6）路径规划：寻找最优路径段

#### 扩展

##### 二维最大子矩阵和问题

```java
        public static int maxSubMatrix(int[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return 0;
    }
    
    int rows = matrix.length;
    int cols = matrix[0].length;
    int maxSum = Integer.MIN_VALUE;
    
    // 固定上下边界，计算这些行的列和
    for (int top = 0; top < rows; top++) {
        int[] temp = new int[cols];  // 存储从top行到bottom行的每列的和
        
        for (int bottom = top; bottom < rows; bottom++) {
            // 更新列和
            for (int col = 0; col < cols; col++) {
                temp[col] += matrix[bottom][col];
            }
            
            // 对列和数组应用1D最大子数组算法
            int currentMaxSum = kadane(temp);
            maxSum = Math.max(maxSum, currentMaxSum);
        }
    }
    
    return maxSum;
}

// 一维Kadane算法
private static int kadane(int[] arr) {
    int maxSoFar = arr[0];
    int maxEndingHere = arr[0];
    
    for (int i = 1; i < arr.length; i++) {
        maxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);
        maxSoFar = Math.max(maxSoFar, maxEndingHere);
    }
    
    return maxSoFar;
}

      
```

#### 测验

这里准备了一些测试题，方便大家判断自己的掌握情况：

1. Kadane算法的时间复杂度和空间复杂度分别是多少？
2. 当数组中全是负数时，最大子数组和是什么？如何处理这种特殊情况？
3. 分治法解决最大子数组问题的时间复杂度为什么是O(n log n)？

> 测验答案
>
> 1. 时间复杂度 O(n)，空间复杂度 O(1)。
> 2. 当数组中全是负数时，最大子数组是数组中的最大值（单个元素）。可以通过先检查是否所有元素都是负数来处理。
> 3. 分治法的时间复杂度可以用递归式表示：T(n) = 2T(n/2) + O(n)，其中2T(n/2)表示处理左右两个子问题，O(n)表示计算跨中点的最大子数组。根据主定理，这个递归式的解为O(n log n)。

### 五、最近点对问题

#### 最近点对问题

最近点对问题是在二维平面上找到距离最近的两个点。分治算法通过将点集按x坐标排序，递归地在左右两半部分寻找最近点对，最后考虑跨越中线的点对。

`时间复杂度:最佳 O(n log n) | 最差 O(n log n)  空间复杂度:O(n)`

#### 算法讲解

##### 介绍

最近点对问题(Closest Pair of Points Problem)是计算几何学中的一个经典问题：给定平面上的n个点，找出其中的一对点，使得它们之间的距离最小。这个问题看似简单，暴力解法可以通过计算所有点对的距离在O(n²)时间内解决，但使用分治策略可以将时间复杂度优化至O(n log n)。该问题在空间索引、聚类分析、碰撞检测等领域有广泛应用。

#### 算法步骤

分治法解决最近点对问题的关键步骤如下：

1. 分解：
   - 将所有点按照x坐标排序
   - 找到中间点，将点集分为左右两部分
2. 解决：
   - 递归求解左半部分的最近点对，距离记为δ₁
   - 递归求解右半部分的最近点对，距离记为δ₂
   - 取δ = min(δ₁, δ₂)
3. 合并：
   - 考虑跨越中线的点对，即一个点在左半部分，一个点在右半部分
   - 只需考虑中线左右各δ距离内的点
   - 对这些点按y坐标排序，对每个点只需与其后最多6个点比较距离
   - 更新最小距离

#### 核心特性

- 高效性：时间复杂度O(n log n)，优于暴力法的O(n²)
- 排序预处理：需要按x坐标和y坐标分别排序
- 空间划分：通过垂直线将平面分为左右两部分
- 剪枝技术：合并阶段通过几何性质大幅减少比较次数
- 递归调用：采用递归结构实现分治过程

#### 代码实现

```java
import java.util.*;

class Point {
    double x, y;
    
    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }
    
    // 计算两点间的欧几里得距离
    public double distance(Point p) {
        return Math.sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));
    }
}

public class ClosestPairOfPoints {
    
    // 暴力方法找最近点对
    private static double bruteForce(Point[] points, int start, int end, Point[] closestPair) {
        double minDist = Double.POSITIVE_INFINITY;
        
        for (int i = start; i < end; i++) {
            for (int j = i + 1; j < end; j++) {
                double dist = points[i].distance(points[j]);
                if (dist < minDist) {
                    minDist = dist;
                    if (closestPair != null) {
                        closestPair[0] = points[i];
                        closestPair[1] = points[j];
                    }
                }
            }
        }
        
        return minDist;
    }
    
    // 合并步骤，检查跨越中线的点对
    private static double stripClosest(Point[] strip, int size, double delta, Point[] closestPair) {
        double minDist = delta;
        
        // 按y坐标排序
        Arrays.sort(strip, 0, size, (a, b) -> Double.compare(a.y, b.y));
        
        // 对每个点，只需检查后面y坐标相差小于delta的点
        for (int i = 0; i < size; i++) {
            // 根据几何性质，只需检查最多6个点
            for (int j = i + 1; j < size && (strip[j].y - strip[i].y) < minDist; j++) {
                double dist = strip[i].distance(strip[j]);
                if (dist < minDist) {
                    minDist = dist;
                    if (closestPair != null) {
                        closestPair[0] = strip[i];
                        closestPair[1] = strip[j];
                    }
                }
            }
        }
        
        return minDist;
    }
    
    // 分治法主函数
    private static double closestUtil(Point[] points, int start, int end, Point[] closestPair) {
        int n = end - start;
        
        // 如果点数少于等于3，使用暴力法
        if (n <= 3) {
            return bruteForce(points, start, end, closestPair);
        }
        
        // 找到中间点
        int mid = start + n/2;
        Point midPoint = points[mid];
        
        Point[] leftClosestPair = new Point[2];
        Point[] rightClosestPair = new Point[2];
        
        // 递归解决左右两部分
        double leftDist = closestUtil(points, start, mid, leftClosestPair);
        double rightDist = closestUtil(points, mid, end, rightClosestPair);
        
        // 取左右两部分的最小距离
        double delta = Math.min(leftDist, rightDist);
        Point[] currentClosestPair = (leftDist <= rightDist) ? leftClosestPair : rightClosestPair;
        if (closestPair != null) {
            closestPair[0] = currentClosestPair[0];
            closestPair[1] = currentClosestPair[1];
        }
        
        // 创建strip数组，存储中线附近的点
        Point[] strip = new Point[n];
        int j = 0;
        for (int i = start; i < end; i++) {
            if (Math.abs(points[i].x - midPoint.x) < delta) {
                strip[j++] = points[i];
            }
        }
        
        // 检查strip中是否有更近的点对
        Point[] stripClosestPair = new Point[2];
        double stripDist = stripClosest(strip, j, delta, stripClosestPair);
        
        // 更新最终结果
        if (stripDist < delta) {
            delta = stripDist;
            if (closestPair != null) {
                closestPair[0] = stripClosestPair[0];
                closestPair[1] = stripClosestPair[1];
            }
        }
        
        return delta;
    }
    
    // 查找最近点对的主方法
    public static double closest(Point[] points, Point[] closestPair) {
        int n = points.length;
        
        // 按x坐标排序
        Arrays.sort(points, (a, b) -> Double.compare(a.x, b.x));
        
        // 调用递归函数
        return closestUtil(points, 0, n, closestPair);
    }
}

```

#### 优缺点

##### 优点

- 高效性：O(n log n)的时间复杂度，适合处理大规模点集
- 精确性：能够精确找到最近点对，不是近似算法
- 可扩展性：可以扩展到三维空间和高维空间
- 稳定性：算法结果稳定，不依赖于输入点的顺序

##### 缺点

- 实现复杂：相比暴力法，实现更为复杂
- 内存消耗：需要额外的空间来存储排序结果和合并阶段的点
- 递归开销：递归调用带来的额外开销
- 不易并行化：合并阶段依赖于之前的计算结果，不容易并行处理

#### 应用场景

- 空间数据库：用于空间索引和最近邻查询
- 计算几何学：作为基础算法用于解决其他几何问题
- 聚类分析：用于确定数据点之间的相似性
- 图像处理：用于特征点匹配和目标识别
- 碰撞检测：在物理模拟和游戏中检测物体间的碰撞
- 无线网络：优化节点间的通信距离

#### 扩展

##### 三维空间中的最近点对问题

在三维空间中，最近点对问题的分治算法核心思想与上述相似，但实现更为复杂：

1. 按x坐标排序并分割点集
2. 递归计算左右两部分的最近点对
3. 合并阶段考虑位于中间平面附近的点
4. 使用三维的剪枝技术减少比较次数

三维空间中，剪枝技术变得更为复杂，需要使用格子或八叉树等空间数据结构来优化。时间复杂度在最坏情况下仍为O(n log n)。

##### 近似算法和概率算法

对于高维空间或对性能要求极高的应用，可以使用近似算法：

1. 网格方法：将空间划分为网格，只比较同一网格和相邻网格中的点
2. KD树索引：使用KD树存储点，能在平均O(log n)时间内找到近似最近点
3. 随机采样：使用随机抽样技术，以牺牲一定精度换取更高效率

##### 流数据处理

在流数据环境中，点是动态添加的，需要维护当前的最近点对：

1. 使用平衡二叉树维护点的x和y坐标排序
2. 对新加入的点，只需检查其与附近点的距离
3. 维护一个候选点集合，保持其大小在O(log n)级别

##### 并行化实现

对于大规模数据，可以采用并行化策略：

1. 将点集分成多个子集，并行计算每个子集的最近点对
2. 合并阶段需要考虑跨越不同子集边界的点对
3. 使用区域重叠技术减少子集边界问题

实际测试表明，在多核环境下，并行实现可以获得接近线性的加速比。

##### 最远点对问题

与最近点对问题相关的是最远点对问题，即找出点集中相距最远的一对点。这个问题可以使用凸包算法解决：

1. 计算点集的凸包
2. 在凸包顶点中找出距离最远的点对（可以使用旋转卡尺算法）

最远点对问题的时间复杂度也是O(n log n)，主要受限于凸包计算的复杂度。

#### 测验

1. 解释为什么在最近点对问题的合并阶段，对于跨越中线的每个点，只需检查y坐标差小于δ的有限个点？
2. 最近点对算法的合并阶段中，为什么我们可以断言每个点只需与其后最多6个点比较距离？请从几何角度证明。
3. 如果二维平面上有n个点，其中存在m对相同的点(m < n/2)，最近点对算法的时间复杂度会发生什么变化？如何优化？
4. 分析最近点对算法在最坏情况下的空间复杂度，并思考如何减少空间消耗。

> 测验答案
>
> 1. 在合并阶段，我们已经知道左右两部分的最小距离δ，对于跨越中线的点对，如果两点的y坐标差大于δ，那么它们之间的距离一定大于δ（毕竟欧几里得距离公式中，y坐标差的平方是总距离平方的一部分）。因此，我们只需检查y坐标差小于δ的点对，这大大减少了需要比较的点对数量。
> 2. 考虑跨越中线的点集，每个点左右δ距离内的区域形成宽度为2δ、高度为2δ的正方形区域。根据鸽巢原理，如果在这个区域中放置超过8个点，必然有两点间距离小于δ（可以将正方形划分为4个边长为δ的小正方形，每个小正方形最多容纳1个点，否则两点距离小于δ）。但这与我们已知的左右两部分最小距离为δ矛盾。更精确的分析表明，每个点实际上最多需要与其后6个点比较距离。
> 3. 如果存在相同的点，最小距离为0。算法可以在初始排序后检测相邻点是否重合，如发现重合点立即返回0距离。时间复杂度仍为O(n log n)，主要由排序决定，但实际运行时间会因提前终止而减少。可以使用哈希表预处理，以O(n)时间检测重合点。
> 4. 最坏情况下，空间复杂度为O(n)，主要用于递归调用栈(O(log n))和合并阶段的strip数组(O(n))。可以通过迭代实现替代递归，或使用原地排序算法减少辅助数组空间，但这会增加实现复杂度。